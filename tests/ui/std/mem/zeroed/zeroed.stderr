error: the type `&T` does not permit zero-initialization
  --> tests/ui/std/mem/zeroed/zeroed.rs:3:34
   |
LL |     let x: &'static T = unsafe { std::mem::zeroed() };
   |                                  ^^^^^^^^^^^^^^^^^^
   |                                  |
   |                                  this code causes undefined behavior when executed
   |                                  help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
   = note: references must be non-null
   = note: `-D invalid-value` implied by `-D warnings`
   = help: to override `-D warnings` add `#[allow(invalid_value)]`

error: the type `&mut T` does not permit zero-initialization
  --> tests/ui/std/mem/zeroed/zeroed.rs:9:38
   |
LL |     let x: &'static mut T = unsafe { std::mem::zeroed() };
   |                                      ^^^^^^^^^^^^^^^^^^
   |                                      |
   |                                      this code causes undefined behavior when executed
   |                                      help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
   = note: references must be non-null

note: MIR of `zeroed_inited_reference`
  --> tests/ui/std/mem/zeroed/zeroed.rs:2:1
   |
LL |   #[rpl::dump_mir()]
   |   ------------------ MIR dumpped because of this attribute
LL | / fn zeroed_inited_reference<T>() -> &'static T {
LL | |     let x: &'static T = unsafe { std::mem::zeroed() };
LL | |     x
LL | | }
   | |_^
   |
   = note: see `/Users/stuuupidcat/home/code/projects/RPL/mir_dump/zeroed.zeroed_inited_reference.-------.dump_mir..mir` for dumpped MIR
note: locals and scopes in this MIR
  --> tests/ui/std/mem/zeroed/zeroed.rs:2:1
   |
LL |    fn zeroed_inited_reference<T>() -> &'static T {
   |    ^                                  ---------- _0: &T; // scope[0]
   |  __|
   | |
LL | |      let x: &'static T = unsafe { std::mem::zeroed() };
   | |      -   - _1: &T; // scope[0]
   | | _____|
   | ||
LL | ||     x
LL | || }
   | || ^
   | ||_|
   |  |_scope[0]
   |    scope[1]
   |
  ::: /Users/stuuupidcat/.rustup/toolchains/nightly-2025-02-14-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/mem/mod.rs:466:1
   |
LL |  / pub const fn align_of<T>() -> usize {
LL |  |     intrinsics::min_align_of::<T>()
LL |  | }
   |  | -
   |  |_|
   |  |_scope[11]
   |    std::mem::align_of::<&T>
...
LL |  / pub const unsafe fn zeroed<T>() -> T {
LL |  |     // SAFETY: the caller must guarantee that an all-zero value is valid for `T`.
LL |  |     unsafe {
LL |  |         intrinsics::assert_zero_valid::<T>();
   |  |         ------------------------------------ _2: (); // scope[2]
...   |
LL |  | }
   |  | -
   |  |_|
   |  |_scope[2]
   |    std::mem::zeroed::<&T>
   |
  ::: /Users/stuuupidcat/.rustup/toolchains/nightly-2025-02-14-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/ub_checks.rs:93:1
   |
LL |  / pub(crate) const fn check_language_ub() -> bool {
LL |  |     // Only used for UB checks so we may const_eval_select.
LL |  |     intrinsics::ub_checks()
LL |            && const_eval_select!(
   |   ____________-
   |   ____________|
   |  |
LL |  |             @capture { } -> bool:
LL |  |             if const {
...   |
LL |  |         )
   |  |         -
   |  |_________|
   |  |_________scope[10]
   |            core::ub_checks::check_language_ub::runtime
LL |  | }
   |  | -
   |  |_|
   |  |_scope[9]
   |    core::ub_checks::check_language_ub
   |
  ::: /Users/stuuupidcat/.rustup/toolchains/nightly-2025-02-14-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/mem/manually_drop.rs:198:5
   |
LL |  /     pub const fn into_inner(slot: ManuallyDrop<T>) -> T {
LL |  |         slot.value
LL |  |     }
   |  |     -
   |  |_____|
   |  |_____scope[13]
   |        std::mem::ManuallyDrop::<&T>::into_inner
   |
  ::: /Users/stuuupidcat/.rustup/toolchains/nightly-2025-02-14-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/mem/maybe_uninit.rs:330:5
   |
LL |  /     pub const fn uninit() -> MaybeUninit<T> {
LL |  |         MaybeUninit { uninit: () }
LL |  |     }
   |  |     -
   |  |_____|
   |  |_____scope[5]
   |        std::mem::MaybeUninit::<&T>::uninit
...
LL |  /     pub const fn zeroed() -> MaybeUninit<T> {
LL |  /         let mut u = MaybeUninit::<T>::uninit();
LL |            // SAFETY: `u.as_mut_ptr()` points to allocated memory.
LL |            unsafe { u.as_mut_ptr().write_bytes(0u8, 1) };
LL |            u
LL |  |     }
   |  |     -
   |  |_____|
   |  |_____scope[3]
   |  |_____std::mem::MaybeUninit::<&T>::zeroed
   |        scope[4]
...
LL |  /     pub const fn as_mut_ptr(&mut self) -> *mut T {
LL |  |         // `MaybeUninit` and `ManuallyDrop` are both `repr(transparent)` so we can cast the pointer.
LL |  |         self as *mut _ as *mut T
LL |  |     }
   |  |     -
   |  |_____|
   |  |_____scope[6]
   |        std::mem::MaybeUninit::<&T>::as_mut_ptr
...
LL |  /     pub const unsafe fn assume_init(self) -> T {
LL |  |         // SAFETY: the caller must guarantee that `self` is initialized.
LL |  |         // This also means that `self` must be a `value` variant.
LL |  |         unsafe {
...   |
LL |  |     }
   |  |     -
   |  |_____|
   |  |_____scope[12]
   |        std::mem::MaybeUninit::<&T>::assume_init
   |
  ::: /Users/stuuupidcat/.rustup/toolchains/nightly-2025-02-14-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/ptr/mut_ptr.rs:1524:5
   |
LL |  /     pub const unsafe fn write_bytes(self, val: u8, count: usize)
LL |  |     where
LL |  |         T: Sized,
...   |
LL |  |         unsafe { write_bytes(self, val, count) }
LL |  |     }
   |  |     -
   |  |_____|
   |  |_____scope[7]
   |        std::ptr::mut_ptr::<impl *mut &T>::write_bytes
   |
  ::: /Users/stuuupidcat/.rustup/toolchains/nightly-2025-02-14-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:4607:1
   |
LL |  / pub const unsafe fn write_bytes<T>(dst: *mut T, val: u8, count: usize) {
LL |  |     #[rustc_intrinsic_const_stable_indirect]
LL |  |     #[rustc_nounwind]
LL |  |     #[rustc_intrinsic]
...   |
LL |  | }
   |  | -
   |  |_|
   |  |_scope[8]
   |    std::intrinsics::write_bytes::<&T>
note: bb0: {
          _2 = std::intrinsics::assert_zero_valid::<&T>() -> unwind unreachable; // scope[2]
      }
  --> /Users/stuuupidcat/.rustup/toolchains/nightly-2025-02-14-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/mem/mod.rs:656:9
   |
LL |         intrinsics::assert_zero_valid::<T>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ _2 = std::intrinsics::assert_zero_valid::<&T>() -> unwind unreachable; // scope[2]

note: MIR of `zeroed_inited_reference_mut`
  --> tests/ui/std/mem/zeroed/zeroed.rs:8:1
   |
LL |   #[rpl::dump_mir()]
   |   ------------------ MIR dumpped because of this attribute
LL | / fn zeroed_inited_reference_mut<T>() -> &'static mut T {
LL | |     let x: &'static mut T = unsafe { std::mem::zeroed() };
LL | |     x
LL | | }
   | |_^
   |
   = note: see `/Users/stuuupidcat/home/code/projects/RPL/mir_dump/zeroed.zeroed_inited_reference_mut.-------.dump_mir..mir` for dumpped MIR
note: locals and scopes in this MIR
  --> tests/ui/std/mem/zeroed/zeroed.rs:8:1
   |
LL |    fn zeroed_inited_reference_mut<T>() -> &'static mut T {
   |    ^                                      -------------- _0: &mut T; // scope[0]
   |  __|
   | |
LL | |      let x: &'static mut T = unsafe { std::mem::zeroed() };
   | |      -   - _1: &mut T; // scope[0]
   | | _____|
   | ||
LL | ||     x
LL | || }
   | || ^
   | ||_|
   |  |_scope[0]
   |    scope[1]
   |
  ::: /Users/stuuupidcat/.rustup/toolchains/nightly-2025-02-14-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/mem/mod.rs:466:1
   |
LL |  / pub const fn align_of<T>() -> usize {
LL |  |     intrinsics::min_align_of::<T>()
LL |  | }
   |  | -
   |  |_|
   |  |_scope[11]
   |    std::mem::align_of::<&mut T>
...
LL |  / pub const unsafe fn zeroed<T>() -> T {
LL |  |     // SAFETY: the caller must guarantee that an all-zero value is valid for `T`.
LL |  |     unsafe {
LL |  |         intrinsics::assert_zero_valid::<T>();
   |  |         ------------------------------------ _2: (); // scope[2]
...   |
LL |  | }
   |  | -
   |  |_|
   |  |_scope[2]
   |    std::mem::zeroed::<&mut T>
   |
  ::: /Users/stuuupidcat/.rustup/toolchains/nightly-2025-02-14-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/ub_checks.rs:93:1
   |
LL |  / pub(crate) const fn check_language_ub() -> bool {
LL |  |     // Only used for UB checks so we may const_eval_select.
LL |  |     intrinsics::ub_checks()
LL |            && const_eval_select!(
   |   ____________-
   |   ____________|
   |  |
LL |  |             @capture { } -> bool:
LL |  |             if const {
...   |
LL |  |         )
   |  |         -
   |  |_________|
   |  |_________scope[10]
   |            core::ub_checks::check_language_ub::runtime
LL |  | }
   |  | -
   |  |_|
   |  |_scope[9]
   |    core::ub_checks::check_language_ub
   |
  ::: /Users/stuuupidcat/.rustup/toolchains/nightly-2025-02-14-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/mem/manually_drop.rs:198:5
   |
LL |  /     pub const fn into_inner(slot: ManuallyDrop<T>) -> T {
LL |  |         slot.value
LL |  |     }
   |  |     -
   |  |_____|
   |  |_____scope[13]
   |        std::mem::ManuallyDrop::<&mut T>::into_inner
   |
  ::: /Users/stuuupidcat/.rustup/toolchains/nightly-2025-02-14-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/mem/maybe_uninit.rs:330:5
   |
LL |  /     pub const fn uninit() -> MaybeUninit<T> {
LL |  |         MaybeUninit { uninit: () }
LL |  |     }
   |  |     -
   |  |_____|
   |  |_____scope[5]
   |        std::mem::MaybeUninit::<&mut T>::uninit
...
LL |  /     pub const fn zeroed() -> MaybeUninit<T> {
LL |  /         let mut u = MaybeUninit::<T>::uninit();
LL |            // SAFETY: `u.as_mut_ptr()` points to allocated memory.
LL |            unsafe { u.as_mut_ptr().write_bytes(0u8, 1) };
LL |            u
LL |  |     }
   |  |     -
   |  |_____|
   |  |_____scope[3]
   |  |_____std::mem::MaybeUninit::<&mut T>::zeroed
   |        scope[4]
...
LL |  /     pub const fn as_mut_ptr(&mut self) -> *mut T {
LL |  |         // `MaybeUninit` and `ManuallyDrop` are both `repr(transparent)` so we can cast the pointer.
LL |  |         self as *mut _ as *mut T
LL |  |     }
   |  |     -
   |  |_____|
   |  |_____scope[6]
   |        std::mem::MaybeUninit::<&mut T>::as_mut_ptr
...
LL |  /     pub const unsafe fn assume_init(self) -> T {
LL |  |         // SAFETY: the caller must guarantee that `self` is initialized.
LL |  |         // This also means that `self` must be a `value` variant.
LL |  |         unsafe {
...   |
LL |  |     }
   |  |     -
   |  |_____|
   |  |_____scope[12]
   |        std::mem::MaybeUninit::<&mut T>::assume_init
   |
  ::: /Users/stuuupidcat/.rustup/toolchains/nightly-2025-02-14-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/ptr/mut_ptr.rs:1524:5
   |
LL |  /     pub const unsafe fn write_bytes(self, val: u8, count: usize)
LL |  |     where
LL |  |         T: Sized,
...   |
LL |  |         unsafe { write_bytes(self, val, count) }
LL |  |     }
   |  |     -
   |  |_____|
   |  |_____scope[7]
   |        std::ptr::mut_ptr::<impl *mut &mut T>::write_bytes
   |
  ::: /Users/stuuupidcat/.rustup/toolchains/nightly-2025-02-14-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:4607:1
   |
LL |  / pub const unsafe fn write_bytes<T>(dst: *mut T, val: u8, count: usize) {
LL |  |     #[rustc_intrinsic_const_stable_indirect]
LL |  |     #[rustc_nounwind]
LL |  |     #[rustc_intrinsic]
...   |
LL |  | }
   |  | -
   |  |_|
   |  |_scope[8]
   |    std::intrinsics::write_bytes::<&mut T>
note: bb0: {
          _2 = std::intrinsics::assert_zero_valid::<&mut T>() -> unwind unreachable; // scope[2]
      }
  --> /Users/stuuupidcat/.rustup/toolchains/nightly-2025-02-14-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/mem/mod.rs:656:9
   |
LL |         intrinsics::assert_zero_valid::<T>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ _2 = std::intrinsics::assert_zero_valid::<&mut T>() -> unwind unreachable; // scope[2]

error: abort due to debugging
  --> tests/ui/std/mem/zeroed/zeroed.rs:1:1
   |
LL | #[rpl::dump_mir()]
   | ^^^^^^^^^^^^^^^^^^
...
LL | #[rpl::dump_mir()]
   | ^^^^^^^^^^^^^^^^^^
   |
   = note: `#[rpl::dump_hir]`, `#[rpl::print_hir]` and `#[rpl::dump_mir]` are only used for debugging
   = note: this error is to remind you removing these attributes
help: remove this attribute
   |
LL - #[rpl::dump_mir()]
   |
help: remove this attribute
   |
LL - #[rpl::dump_mir()]
   |

error: aborting due to 3 previous errors

