# CVE-2020-35870/CVE-2020-35871 

## Metadata
- RustSec: https://rustsec.org/advisories/RUSTSEC-2020-0014.html
- Mitre: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-35870https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-35871
- Bug Report GitHub Issue/Release: https://github.com/rusqlite/rusqlite/releases/tag/0.23.0
- Bug Fix Github Commit/PR: https://github.com/rusqlite/rusqlite/commit/2ef3628dac35aeba0a97d5fb3a57746b4e1d62b3?diff=split&w=1

## Source
```rust
unsafe extern "C" fn free_boxed_value<T>(p: *mut c_void) {
    drop(Box::from_raw(p as *mut T));
}

pub struct Context<'a> {
    ctx: *mut sqlite3_context,
    args: &'a [*mut sqlite3_value],
}

impl Context<'_> {
    // ...
    pub fn set_aux<T: 'static>(&self, arg: c_int, value: T) {
        let boxed = Box::into_raw(Box::new(AuxData {
            id: TypeId::of::<T>(),
            value,
        }));
        unsafe {
            ffi::sqlite3_set_auxdata(
                self.ctx,
                arg,
                boxed as *mut c_void,
                Some(free_boxed_value::<AuxData<T>>),
            )
        };
    }

    pub fn get_aux<T: 'static>(&self, arg: c_int) -> Result<Option<&T>> {
        let p = unsafe { ffi::sqlite3_get_auxdata(self.ctx, arg) as *const AuxData<T> };
        if p.is_null() {
            Ok(None)
        } else {
            let id = unsafe { (*p).id };
            if TypeId::of::<T>() != id {
                Err(Error::GetAuxWrongType)
            } else {
                Ok(Some(unsafe { &(*p).value }))
            }
        }
    }
    // ...
}

#[repr(C)]
struct AuxData<T: 'static> {
    id: TypeId,
    value: T,
}
```

## Description / Analysis

- In `Context::set_aux::<T>`, `Box<AuxData<T>>` are leaked via `Box::into_raw` and passed to an FFI function `sqlite3_set_auxdata` as a `*mut AuxData<T>` pointer. In addition, the function `free_boxed_value` which frees a `Box` via `Box::from_raw`, is also passed to `sqlite3_set_auxdata`, and we can see that `Box::from_raw` matches `Box::into_raw` in the construction and the destruction of a `Box`.
- In `Context::get_aux::<T>`, the FFI fucntion `sqlite3_get_auxdata` is used and gets a `*const AuxData<T>`, and then it returns an `&T` dereferenced from `AuxData::value`.

All these things work only if:
- `free_boxed_value` can only be called after every `sqlite3_get_auxdata`, or otherwise it can cause a use-after-free.
- After `sqlite3_set_auxdata` called, the FFI functions should not mutate the `*mut AuxData<T>` passed in, or the aliasing rule will be broken with the returned `&T`.
- If the FFI function may send or share the `*mut AuxData<T>` accross different threads, there must be `T: Send` or `T: Sync`, respectively.

## Fixes

The `AuxData` should be wrapped in an `Arc`, in order to prevent the FFI functions freeing it while we are still use it in Rust.

## Pattern Description

````rpl
pattern CVE-2020-35870/CVE-2020-35871

mvar {
    R W: adt
    t v id: field
    T: ident
    Arg: ty
    FfiCtx Ctx: ty*
    free ffi_set ffi_get: fn
    free_def free_arg ret call_set: span
}

util {
    p_wrapper = adt $W {
        self.**.$v: $T,
        ..
    }
    p_result = pub adt $R {
        self.**.$t: Option<&$T>,
        ..
    }
    p_free = pub adt $Free {
        self.**.$f: extern "C" unsafe fn(*mut c_void),
        ..
    }
    p_ffi_set = extern "C" unsafe fn $ffi_set($(_: $FfiCtx,)*, _: *mut c_void, _: $Free) -> _;
    p_ffi_get = extern "C" unsafe fn $ffi_get($(_: $FfiCtx,)*) -> *mut c_void;
    p_free = #span![$free_def] extern "C" unsafe fn $free(ptr: *mut c_void) {
        return unsafe { Box::from_raw(ptr) };
    }
    p_set = pub fn _<$T>($(_: $Ctx)*, value: $T) {
        let boxed: Box<$W> = Box::new($W { $v });
        let ptr: *mut $W = Box::into_raw(boxed);
        unsafe {
            #span!($call_set, $ffi_set($(_,)*, ptr as *mut c_void, $Free { $f: #span!($free_arg, $free) }));
        }
    }
    p_get = pub fn _<$T>($(_: $Ctx)*) -> #span!($ret, $R) {
        let ptr* *mut $W = unsafe { $ffi_get($(_,)*) as *mut $W };
        if ptr.is_null() {
            return $R { $t: None };
        } else {
            return unsafe { $R { $t: Some(&(*ptr).$v) } };
        }
    }
}

patt {
    p: err =
        & p_wrapper
        & p_result
        & p_free
        & p_ffi_set
        & p_ffi_get
        & p_free
        & p_set
        & p_get => MayDangle {
            $ret,
            $call_set,
            $free_arg,
            $free_def,
            $T,
            $free: #ident!($free),
        }

}

use {
    core::ffi::c_void
}

diag {
    #[derive(Diagnostic)]
    #[diag(may_dangle)]
    pub struct MayDangle {
        #[primary_span]
        #[help]
        pub ret: Span,
        #[note]
        pub call_set: Span,
        #[label]
        pub free_arg: Span,
        #[note(free_def_note)]
        pub free_def: Span,
        pub T: Ident,
        pub free: Ident,
    }
}

msg {
    may_dangle = the returned `&{$T}` may dangle
        .help = wrap `{$T}` into an `Arc`, and clone it before return
        .note = a destructor `{$free}` is passed into this FFI function
        .label = destructor passed as an argument here
        .free_def_note = `{$free}` defined here
}
````

## Expected Diagnostics

````
error: the returned `&T` may dangle
  --> $FILE.rs:LL:CC
   |
LL |    pub fn get_aux<T: 'static>(&self, arg: c_int) -> Result<Option<&T>> {
   |                                                     ^^^^^^^^^^^^^^^^^^ help: wrap `T` into an `Arc`, and clone it before return
help: wrap `T` into an `Arc`, and clone it before return
  --> $FILE.rs:LL:CC
   |
LL |    pub fn get_aux<T: 'static>(&self, arg: c_int) -> Result<Option<&T>> {
   |                                                     ^^^^^^^^^^^^^^^^^^
note: a destructor `free_boxed_value` is passed into this FFI function
  --> $FILE.rs:LL:CC
   |
LL | /            ffi::sqlite3_set_auxdata(
LL | |                self.ctx,
LL | |                arg,
LL | |                boxed as *mut c_void,
LL | |                Some(free_boxed_value::<AuxData<T>>),
   | |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ destructor passed as an argument here
LL | |            )
   | |____________^
note: `free_boxed_value` defined here
  --> $FILE.rs:LL:CC
   |
LL | / unsafe extern "C" fn free_boxed_value<T>(p: *mut c_void) {
LL | |     drop(Box::from_raw(p as *mut T));
LL | | }
   | |_^
````