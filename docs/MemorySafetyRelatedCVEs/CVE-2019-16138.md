# CVE-2019-16138

## Metadata

- RustSec: _
- Mitre: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-16138
- Bug Report GitHub Issue/Release: https://github.com/image-rs/image/issues/980
- Bug Fix GitHub Commit/PR: https://github.com/image-rs/image/pull/887/files#diff-9e9af5d18e72ec657d6b3c02cf35c490

## Source

```rust
let mut ret = Vec::with_capacity(pixel_count);
unsafe {
    // RGBE8Pixel doesn't implement Drop, so it's Ok to drop half-initialized ret
    ret.set_len(pixel_count);
} // ret contains uninitialized data, so now it's my responsibility to return fully initialized ret
```

## Description / Analysis

Similar to [CVE-2018-20992](./CVE-2018-20992.md).

Use of uninitialized data (from `buffer.len()` to `new_len`.

`set_len` 's safety requirements are:

- new_len must be less than or equal to capacity().
- The elements at old_len..new_len must be initialized.

## Fixes

TODO

## Pattern Description

TODO
````rpl
pattern CVE-2019-16138

mvar {
    len: ident
    buf: ident
    set_len: span
}

util {
    p_set_len = ?pub ?unsafe fn _(_) -> _ {
        let $len: usize = _;
        let $buf: Vec<_> = Vec::with_capacity($len);
        unsafe { #span!($set_len, buf.set_len($len)); }
    }
}

use {
    std::vec::Vec
}

patt {
    p: err = p_set_len => SetLenError {
        $set_len,
        $buf,
        $len,
    }
}

diag {
    #[derive(Diagnostic)]
    #[diag(set_len_error)]
    pub struct SetLenError {
        #[primary_span]
        #[suggestion(code = "{buf}.resize({len}, Default::default())")]
        pub set_len: Span,
        pub buf: Ident,
        pub len: Ident,
    }
}

msg {
    set_len_error = 
            setting a length `{$len}` to an empty `{$buf}`
            will expose uninitialized memory
        .suggestion = try a safe API `resize`
}
````
