# `Unpin` and `Pin` (CVE-2020-35901 / 35902)

## `Unpin` (Trait)

Types that do not require any pinning guarantees.

Most types in Rust are `Unpin`.

## `Pin` (Struct)

`Pin` is a wrapper around some kind of pointer `Ptr` which makes that pointer “pin” its pointee value in place.

> "`Pin` 是 Rust 为了保证安全性加的一层马甲。"

When we want to pin a value in stack, `Pin` works by the following rules:

**(1) For `T: Unpin`, `Pin<&mut T>` is the same as `&mut T`.**

For a type `T` that implements `Unpin`, `Pin<&mut T>` is the same as `&mut T`.

-   There is a safe constructor `Pin::new -> Pin<&mut T>`.
-   We can get the mutable reference of the inner value in safe code.

**(2) For `T:!Unpin`**

-   There is only an unsafe constructor `Pin::new_unchecked -> Pin<&mut T>`
-   There is no way to get the mutable reference of the inner value in safe code.

The post obigation of `Pin::new_unchecked` is that: a value, once pinned, should remain pinned until it is dropped.

If the caller that is constructing this Pin<Ptr> does not ensure that the data Ptr points to is pinned, that is a violation of the API contract and may lead to undefined behavior in later (even safe) operations.

## An example with UB

```rust
#![feature(negative_impls)]

use std::pin::Pin;

struct A {
    moveable_string: String,
    ptr: *const String,
}

impl !std::marker::Unpin for A {}

impl A {
    fn new(s: String) -> Self {
        let a = A {
            moveable_string: s,
            ptr: std::ptr::null(),
        };
        // a.ptr = &a.moveable_string;
        a
    }
    fn set_ptr(&mut self) {
        self.ptr = &self.moveable_string;
    }

    fn get_string(&self) -> &String {
        &self.moveable_string
    }

    unsafe fn get_string_by_ptr(&self) -> &String {
        unsafe { &*self.ptr }
    }

    unsafe fn call_pinned(self: Pin<&mut Self>) {
        //guarantee that a value, once pinned, remains pinned until it is dropped
        print!("call_pinned: ");
        print!("self.get_string() = {}, ", self.get_string());
        print!("self.get_string_by_ptr() = {}\n", self.get_string_by_ptr());
    }
}

fn main() {
    let mut a = A::new("Hello".to_string());
    a.set_ptr();

    let mut b = A::new("World".to_string());
    // b.set_ptr();

    unsafe {
        let pinned_a = Pin::new_unchecked(&mut a);
        pinned_a.call_pinned();
    }

    std::mem::swap(&mut a, &mut b);

    unsafe {
        let pinned_a = Pin::new_unchecked(&mut a);
        pinned_a.call_pinned();
    }
}
```

The output of the above code is:

```shell
call_pinned: self.get_string() = Hello, self.get_string_by_ptr() = Hello

thread 'main' panicked at src/main.rs:29:18:
null pointer dereference occurred
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
thread caused non-unwinding panic. aborting.
[1]    26215 abort      cargo run
```

## A normal way to use a `Pin`

```rust
#![feature(negative_impls)]

use std::pin::Pin;

struct A {
    moveable_string: String,
    ptr: *const String,
}

impl !std::marker::Unpin for A {}

impl A {
    fn new(s: String) -> Self {
        let a = A {
            moveable_string: s,
            ptr: std::ptr::null(),
        };
        a
    }
    fn set_ptr(&mut self) {
        self.ptr = &self.moveable_string;
    }
}

fn main() {
    let mut a = A::new("hello".to_string());
    a.set_ptr();
    let a: Pin<&mut A> = unsafe { Pin::new_unchecked(&mut a) }; // shadowing
    // from here
    // we cannot get the mutable reference of the inner value from safe code
}
```

## The RPL Pattern

```rust
pattern pin_new_unchecked

pattern {
    p[
        $T:ty,
    ] = fn _ (..) -> _ {
        let mut $t: $T = _;
        let mut $t_ref: &mut $T = &mut $t;
        'create: let mut $pinned_t: std::pin::Pin<&mut $T>
        				= std::pin::Pin::<_> { __pointer: copy $t_ref };
        'drop: storagedead($t);
    } where {
        $T: !std::marker::Unpin,
        Moved($t, 'create, 'drop)
    }
}
```

## Reference

-   A link to an encrypted external resource: https://www.yuque.com/frankking/wceyqq/qu21pvvlvue8a1pa
