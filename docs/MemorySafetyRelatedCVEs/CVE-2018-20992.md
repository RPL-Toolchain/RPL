# CVE-2018-20992

## Metadata

- RustSec: https://rustsec.org/advisories/RUSTSEC-2018-0004.html
- Mitre: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-20992
- Bug Report GitHub Issue/Release: https://github.com/ruuda/claxon/issues/10
- Bug Fix GitHub Commit/PR: https://github.com/rustsec/advisory-db/pull/54

## Source

```rust
fn ensure_buffer_len(mut buffer: Vec<i32>, new_len: usize) -> Vec<i32> {
    if buffer.len() < new_len {
        if buffer.capacity() < new_len {
            buffer = Vec::with_capacity(new_len);
        }
        unsafe { buffer.set_len(new_len); }
    } else {
        buffer.truncate(new_len);
    }
    buffer
}
```

## Description / Analysis

Use of uninitialized data (from `buffer.len()` to `new_len`.

`set_len` 's safety requirements are:

- new_len must be less than or equal to capacity().
- The elements at old_len..new_len must be initialized.

## Fixes

TODO

## Pattern Description

````rpl
pattern CVE-2018-20992

mvar {
    buf: ident
    set_len: span
    new_len: span
    cmp: span
}

util {
    p_set_len = ?pub ?unsafe fn _(_) -> _ {
        let $buf: &mut Vec<_> = _; // Also matches `let mut buf: Vec<_> = _;`
        let new_len: usize = #span!($new_len, _);
        let old_len: usize = $buf.len();
        if #span!($cmp, old_len < new_len) {
            unsafe { #span!($set_len, $buf.set_len(new_len)) };
        }
    }
}

use {
    std::vec::Vec
}

patt {
    p: err = p_set_len => SetLenError {
        $set_len,
        new_len: snippet($new_len),
        $cmp,
        $buf,
    }
}

diag {
    #[derive(Diagnostic)]
    #[diag(set_len_error)]
    pub struct SetLenError {
        #[primary_span]
        pub set_len: Span,
        pub new_len: String,
        #[label]
        pub cmp: Span,
        pub buf: Ident,
    }
}

msg {
    set_len_error = 
            setting a length `{$new_len}` larger than `{$buf}`'s length 
            will expose uninitialized memory
        .label = maybe incorrect comparison
}
````
