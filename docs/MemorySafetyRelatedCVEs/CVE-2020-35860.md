# CVE-2020-35860

## Metadata

-   RustSec: https://rustsec.org/advisories/RUSTSEC-2020-0005.html
-   Mitre: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-35860
-   Bug Report GitHub Issue/Release: https://github.com/TomBebbington/cbox-rs/issues/2
-   Bug Fix GitHub Commit/PR: \_

## Functions

The `CBox` struct:

-   provides a uniform API for C pointers that are owned by Rust types
-   calls the C destructor when it falls out of scope

## Source

```rust
extern crate libc;
use std::{ffi::CStr, ops::Deref};
use libc::{free, c_void, c_char};

pub struct CBox<D:?Sized> where D:DisposeRef {
    pub ptr: *mut D::RefTo
}

impl<'a> Deref for CBox<str> {
    type Target = str;
    fn deref(&self) -> &str {
        unsafe {
            let text = CStr::from_ptr(self.ptr);
            std::str::from_utf8_unchecked(text.to_bytes())
        }
    }
}

pub trait DisposeRef {
    /// What a reference to this type represents as a C pointer.
    type RefTo;
    /// Destroy the contents at the pointer's location.
    ///
    /// This should run some variant of `libc::free(ptr)`
    unsafe fn dispose(ptr: *mut Self::RefTo) {
        free(ptr as *mut c_void);
    }
}

impl DisposeRef for str {
    type RefTo = c_char;
}
```

## Description / Analysis

The function signature of `CStr::from_ptr` is as follows:

```rust
pub unsafe fn from_ptr<'a>(ptr: *const i8) -> &'a CStr
```

The safety requirements for this function are as follows:

-   The memory pointed to by ptr must contain a valid nul terminator at the end of the string.

-   ptr must be valid for reads of bytes up to and including the nul terminator. This means in particular:

    -   The entire memory range of this CStr must be contained within a single allocated object!
    -   **ptr must be non-null even for a zero-length cstr**.

-   The memory referenced by the returned CStr must not be mutated for the duration of lifetime 'a.

-   The nul terminator must be within isize::MAX from ptr

