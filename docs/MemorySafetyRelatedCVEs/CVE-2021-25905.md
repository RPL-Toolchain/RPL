# CVE-2021-25905

## Metadata

- RustSec: https://rustsec.org/advisories/RUSTSEC-2021-0008.html
- Mitre: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-25905
- Bug Report GitHub Issue/Release: https://github.com/Enet4/bra-rs/issues/1
- Bug Fix GitHub Commit/PR: https://github.com/Enet4/bra-rs/pull/2

## Source

```rust
pub struct GreedyAccessReader<R> {
    inner: R,
    buf: Vec<u8>,
    consumed: usize,
}

impl<R> BufRead for GreedyAccessReader<R>
where
    R: Read,
{
    fn fill_buf(&mut self) -> IoResult<&[u8]> {
        if self.buf.capacity() == self.consumed {
            self.reserve_up_to(self.buf.capacity() + 16);
        }

        let b = self.buf.len();
        let buf = unsafe {
            // safe because it's within the buffer's limits
            // and we won't be reading uninitialized memory
            std::slice::from_raw_parts_mut(
                self.buf.as_mut_ptr().offset(b as isize),
                self.buf.capacity() - b)
        };

        match self.inner.read(buf) {
            Ok(o) => {
                unsafe {
                    // reset the size to include the written portion,
                    // safe because the extra data is initialized
                    self.buf.set_len(b + o);
                }

                Ok(&self.buf[self.consumed..])
            }
            Err(e) => Err(e),
        }
    }
}
```

## Description / Analysis

`Read` trait documentation explains the issue:

- It is your responsibility to make sure that **buf is initialized** before calling read. Calling read with an uninitialized buf (of the kind one obtains via MaybeUninit<T>) is not safe, and can lead to undefined behavior.

The vec[len..cap-1] is not initialized, and the read function will write to it. This can lead to undefined behavior.

### Maybe Relative Code

```rust
fn f() {
    let mut vec = Vec::<u8>::with_capacity(10);
    vec.push(100_u8);
    let buf = unsafe {
        let buf = vec.as_mut_ptr().add(vec.len());
        std::slice::from_raw_parts_mut(buf, vec.capacity() - vec.len())
    };
    // read string from stdin
    let stdin = std::io::stdin();
    let mut handle = stdin.lock();
    let n = handle.read(buf).unwrap();
    unsafe {
        vec.set_len(vec.len() + n);
    }
    println!("{:?}", vec);
}
```

## Fixes

```rust
fn fill_buf(&mut self) -> IoResult<&[u8]> {
    if self.buf.capacity() == self.consumed {
        self.reserve_up_to(self.buf.capacity() + 16);
    }

   let b = self.buf.len();
   self.buf.resize(self.buf.capacity(), 0);
   let buf = &mut self.buf[b..];
   let o = self.inner.read(buf)?;

    // truncate to exclude non-written portion
    self.buf.truncate(b + o);

    Ok(&self.buf[self.consumed..])
}
```

1. use `resize` to initialize the buffer
2. `truncate` the buffer to exclude the non-written portion

## Pattern Description

````rpl
pattern CVE-2021-25905

mvar {
    T: ty
    slice: span
}

util {
    p_fn = ?pub ?unsafe fn _(_) -> _ {
        let mut vec: Vec<$T> = _;
        let len: usize = vec.len();
        let cap: usize = vec.capacity();
        let rem: usize = cap - len;
        let ptr: *mut $T = vec.as_mut_ptr().add(len);
        let _: &mut [$T] = unsafe { 
            #span!(slice, from_raw_parts_mut(ptr, rem));
        }
    }
}

patt {
    p: err = p_fn => VecUninitMem {
        $slice,
    }
}

use {
    alloc::vec::Vec
    core::slice::from_raw_parts_mut
}

diag {
    #[derive(Diagnostic)]
    #[diag(vec_uninit_mem)]
    #[help]
    pub struct VecUninitMem {
        #[primary_span]
        pub slice: Span,
    }
}

msg {
    vec_uninit_mem = construct a slice from uninitialized memory
        .help = consider using `Vec::spare_capacity_mut` instead
}
````


`xcb::xproto::change_property` has (among others) the arguments `format: u8` and
`data: &[T]`. The intended use is one of the following cases:

`format = 8` and `T = u8`
`format = 16` and `T = u16`
`format = 32` and `T = u32`
However, this constraint is not enforced. For example, it is possible to call
the function with `format = 32` and `T = u8`. In this case, a read beyond the
end of the data slice is performed and the bytes are sent to the X11 server.
The users of the xcb crate are advised to only call this function with one of
the intended argument combinations.

