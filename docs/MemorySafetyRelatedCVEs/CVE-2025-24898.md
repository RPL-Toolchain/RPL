# CVE-2025-24898

## Metadata

- RustSec: \_
- Mitre: https://www.cve.org/CVERecord?id=CVE-2025-24898
- Bug Fix GitHub Commit/PR: <https://github.com/sfackler/rust-openssl/pull/2360/>

See <https://manpages.debian.org/experimental/libssl-doc/SSL_select_next_proto.3ssl.en.html> for details.

> `SSL_select_next_proto()` is a helper function used to select protocols. It implements the standard protocol selection. It is expected that this function is called from the application callback `cb`. The protocol data in `server`, `server_len` and `client`, `client_len` must be in the protocol-list format described below. The first item in the `server`, `server_len` list that matches an item in the `client`, `client_len` list is selected, and returned in `out`, `outlen`. **The `out` value will point into either server or client, so it should be copied immediately**. The client list must include at least one valid (nonempty) protocol entry in the list.

```C
int SSL_select_next_proto(unsigned char **out, unsigned char *outlen,
                          const unsigned char *server,
                          unsigned int server_len,
                          const unsigned char *client,
                          unsigned int client_len);
```

Implementation of `select_next_proto` before the fix:

```rust
/// A standard implementation of protocol selection for Application Layer Protocol Negotiation
/// (ALPN).
///
/// `server` should contain the server's list of supported protocols and `client` the client's. They
/// must both be in the ALPN wire format. See the documentation for
/// [`SslContextBuilder::set_alpn_protos`] for details.
///
/// It will select the first protocol supported by the server which is also supported by the client.
///
/// [`SslContextBuilder::set_alpn_protos`]: struct.SslContextBuilder.html#method.set_alpn_protos
#[corresponds(SSL_select_next_proto)]
pub fn select_next_proto<'a>(server: &[u8], client: &'a [u8]) -> Option<&'a [u8]> {
    unsafe {
        let mut out = ptr::null_mut();
        let mut outlen = 0;
        let r = ffi::SSL_select_next_proto(
            &mut out,
            &mut outlen,
            server.as_ptr(),
            server.len() as c_uint,
            client.as_ptr(),
            client.len() as c_uint,
        );
        if r == ffi::OPENSSL_NPN_NEGOTIATED {
            Some(util::from_raw_parts(out as *const u8, outlen as usize))
        } else {
            None
        }
    }
}
```

The fix:

```diff
/// A standard implementation of protocol selection for Application Layer Protocol Negotiation
/// (ALPN).
///
/// `server` should contain the server's list of supported protocols and `client` the client's. They
/// must both be in the ALPN wire format. See the documentation for
/// [`SslContextBuilder::set_alpn_protos`] for details.
///
/// It will select the first protocol supported by the server which is also supported by the client.
///
/// [`SslContextBuilder::set_alpn_protos`]: struct.SslContextBuilder.html#method.set_alpn_protos
#[corresponds(SSL_select_next_proto)]
- pub fn select_next_proto<'a>(server: &[u8], client: &'a [u8]) -> Option<&'a [u8]> {
+ pub fn select_next_proto<'a>(server: &'a [u8], client: &'a [u8]) -> Option<&'a [u8]> {
    unsafe {
        let mut out = ptr::null_mut();
        let mut outlen = 0;
        let r = ffi::SSL_select_next_proto(
            &mut out,
            &mut outlen,
            server.as_ptr(),
            server.len() as c_uint,
            client.as_ptr(),
            client.len() as c_uint,
        );
        if r == ffi::OPENSSL_NPN_NEGOTIATED {
            Some(util::from_raw_parts(out as *const u8, outlen as usize))
        } else {
            None
        }
    }
}
```
