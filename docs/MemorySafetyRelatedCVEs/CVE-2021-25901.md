# CVE-2021-25901

## Metadata

- RustSec: https://rustsec.org/advisories/RUSTSEC-2021-0004.html
- Mitre: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-25901
- Bug Report GitHub Issue/Release: https://github.com/khuey/lazy-init/issues/9
- Bug Fix GitHub Commit/PR: https://github.com/khuey/lazy-init/pull/16/commits/f6d9bc6e8f6ad7f0d949a444a1c1d91d6d837e67

## Source

```rust
enum ThisOrThat<T, U> {
    This(T),
    That(U),
}

/// `LazyTransform<T, U>` is a synchronized holder type, that holds a value of
/// type T until it is lazily converted into a value of type U.
pub struct LazyTransform<T, U> {
    initialized: AtomicBool,
    lock: Mutex<()>,
    value: UnsafeCell<Option<ThisOrThat<T, U>>>,
}

unsafe impl<T, U> Sync for LazyTransform<T, U>
where
    T: Sync + Send,
    U: Sync, // fix: Sync + Send
{
}
```

## Description / Analysis

A tricky one about `Send` and `Sync` trait.

Rudra has found many CVEs related to `Send` and/or `Sync` traits, most of which have the following form:

```Rust
struct S<T> {...}

unsafe impl<T> Send for S<T> {}
// fix
unsafe impl<T: Send> Send for S<T> {}
```

### Trait `Send`

- A type is `Send` if it is safe to send it to another thread. (From Rustonomicon)
- Types that can be transferred across thread boundaries. (From std::marker::Send)
- Send allows an object to be used by two threads A and B at _different_ times. Thread A can create and use an object, then send it to thread B, so thread B can use the object while thread A cannot. (From an awswer to the question "understanding-the-send-trait" in stackoverflow)

### Trait `Sync`

- A type is `Sync` if it is safe to share between threads. (From Rustonomicon)

- Types for which it is safe to share references between threads (T is Sync if and only if `&T` is Send). (From std::marker::Sync)

- `Sync` allows an object to to be used by two threads A and B at the _same_ time.

  - Trivial for non-mutable objects
  - Mutations need to be synchronized for mutable objects, which is often done by is often done using a [`Mutex`](https://doc.rust-lang.org/std/sync/struct.Mutex.html) or [`RwLock`](https://doc.rust-lang.org/std/sync/struct.RwLock.html) which allows one thread to proceed while others must wait.
  - Using atomic types

  (From an awswer to the question "understanding-the-send-trait" in stackoverflow)

**`Sync` usually implies `Send` ; There are few examples of types that are `Sync` but not `Send`.**

## Fixes

`Sync + Send`.

## Pattern Description

TODO

## Some Exceptions

### `MutexGuard`

```rust
#[stable(feature = "rust1", since = "1.0.0")]
impl<T: ?Sized> !Send for MutexGuard<'_, T> {}
#[stable(feature = "mutexguard", since = "1.19.0")]
unsafe impl<T: ?Sized + Sync> Sync for MutexGuard<'_, T> {}
```

Some locks require that lock and unlock must be on the same thread, so MutexGuard: !Send. The implementation of `MutexGuard` requires you to ensure you don't try to free a lock that you acquired in a different thread.
