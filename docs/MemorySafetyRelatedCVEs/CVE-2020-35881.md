# CVE-2020-35881

## Metadata

- RustSec: https://rustsec.org/advisories/RUSTSEC-2020-0027.html
- Mitre: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-35881
- Bug Report GitHub Issue/Release: https://github.com/reem/rust-traitobject/issues/7
- Bug Fix GitHub Commit/PR: https://github.com/reem/rust-traitobject/commit/99b1993a13bf80e93031048586526384d1d8bddc

> traitobject:
>
> - Unsafe helpers for dealing with raw trait objects
> - Last update was seven years ago
> - 8000 downloads on 2024-08-14

## Source

```rust
/// Get the data pointer from a trait object.
pub unsafe fn get_data<T: ?Sized>(val: *const T) -> *const () {
    *mem::transmute::<*const *const T, *const *const ()>(&val)
}
```

```rust
/// Get the data pointer from a trait object, mutably.
pub unsafe fn get_data_mut<T: ?Sized>(mut val: *mut T) -> *mut () {
    *mem::transmute::<*mut *mut T, *mut *mut ()>(&mut val)
}
```

## Description / Analysis

### Introduction to "Fat Pointers"

"Fat pointer" is used to refer to references and raw pointers to dynamically sized types (DSTs) â€“ slices or trait objects.

Each instance of a pointer to a trait object includes:

- a pointer to an instance of a type `T` that implements SomeTrait (i.e. a data pointer).
- a virtual method table, which contains, for each method of SomeTrait and its supertraits that T implements, a pointer to `T`'s implementation (i.e. a function pointer).

A reference to a trait object can be basically represented as:

```rust
struct TraitObjectRef {
    data_ptr: *const (),
    vtable_ptr: *const (),
}
```

However, the Rust Compiler **does not** expose the layout of "fat pointers" to the user, i.e., we **cannot** assume that the data pointer is the first 8 bytes of the reference/raw pointer.

### A simple example

Here is a simpler example with the wrong assumption:

```rust
fn test() {
    let mut val = 7_u32;
    let fat_ptr = &mut val as &mut dyn Send;
    println!("size of &dyn Send: {}", std::mem::size_of_val(&fat_ptr)); // 16
    let (data_ptr, _vtable_ptr): (&mut u32, &mut u32) = unsafe { // wrong assmuption
        mem::transmute(fat_ptr)
    };
    *data_ptr += 1_u32;
    println!("val: {}", val); // 8
}
```

### The CVE's example

The function `get_data` is supposed to extract the data pointer from a trait object.

```rust
// equal to `*mem::transmute::<*const *const T, *const *const ()>(&val)`
pub unsafe fn get_data1<T: ?Sized>(maybe_fat_ptr: *const T) -> *const ()
{
    // *const T could be 8 bytes or 16 bytes:
    //     - if T is a trait object, it's 16 bytes
    //     - if T is a sized type, it's 8 bytes
    let ptr_to_maybe_fat_ptr: *const *const T = &maybe_fat_ptr;
    let ptr_to_data_ptr: *const *const () = mem::transmute(ptr_to_maybe_fat_ptr);
    let data_ptr: *const () = *ptr_to_data_ptr;
    data_ptr
}
```

### Another example in [dyn_derive](https://github.com/shigma/dyn_derive/blob/main/dyn_std/src/any.rs)

```rust
pub trait Fat<T: ?Sized>: AsRef<T> + Sized {
    fn into_box(self, f: impl FnOnce(Self) -> *mut ()) -> Box<T> {
        let mut fat_ptr = self.as_ref() as *const T;
        let data_ptr = &mut fat_ptr as *mut *const T as *mut *mut ();
        unsafe {
            *data_ptr = f(self);
            Box::from_raw(fat_ptr as *mut T)
        }
    }

    fn to_box(self, f: impl FnOnce(&T) -> *mut ()) -> Box<T> {
        let mut fat_ptr = self.as_ref() as *const T;
        let data_ptr = &mut fat_ptr as *mut *const T as *mut *mut ();
        unsafe {
            *data_ptr = f(self.as_ref());
            Box::from_raw(fat_ptr as *mut T)
        }
    }
}
```

## Fixes

### Stable Rust

```rust
pub unsafe fn get_data<T: ?Sized>(val: *const T) -> *const() {
    val as *const ()
}
```

Explanation: The Compiler guarantees that when you do something like this, you will get the data pointer.

```rust
fn get_data(_1: *const T) -> *const () {
    debug val => _1;
    let mut _0: *const ();

    bb0: {
        _0 = _1 as *const () (PtrToPtr);
        return;
    }
}
```

Explanation Explanation: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.Rvalue.html#variant.Cast

### Nightly Rust

#### Function `std::ptr::from_raw_parts`

```rust
pub const fn from_raw_parts<T>(
    data_pointer: *const impl Thin,
    metadata: <T as Pointee>::Metadata,
) -> *const T
where
    T: ?Sized,
```

Forms a (possibly-wide) raw pointer from a data pointer and metadata.

This function is safe but the returned pointer is not necessarily safe to dereference. For slices, see the documentation of slice::from_raw_parts for safety requirements. For trait objects, the metadata must come from a pointer to the same underlying erased type.

#### Function `std::ptr::metadata`

```rust
pub const fn metadata<T>(ptr: *const T) -> <T as Pointee>::Metadata
where
    T: ?Sized,
```

Extract the metadata component of a pointer.

- For slices, this is the length of the slice.
- For trait objects, this is the vtable pointer.

Values of type `*mut T`, `&T`, or `&mut T` can be passed directly to this function as they implicitly coerce to `*const T`.

## Pattern Description

HIR or MIR patterns.
