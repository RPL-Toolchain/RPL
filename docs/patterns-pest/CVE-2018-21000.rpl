pattern CVE-2018-21000

patt {
    use alloc::vec::Vec;
    use core::ptr::non_null::NonNull;
    use core::ptr::unique::Unique;
    use alloc::raw_vec::Cap;
    // use alloc::raw_vec::RawVecInner;
    use alloc::raw_vec::RawVec;
    use alloc::alloc::Global;
    use core::marker::PhantomData;

    p_u8_to_t_misordered_para[
        $T: type
    ] = fn _ (..) -> _ {
        type VecU8 = alloc::vec::Vec::<u8>;
        type VecT = alloc::vec::Vec::<$T>;
        type NonNullU8 = core::ptr::non_null::NonNull::<u8>;
        type UniqueU8 = core::ptr::unique::Unique::<u8>;
        type RawVecInner = alloc::raw_vec::RawVecInner;
        type RawVecT = alloc::raw_vec::RawVec::<$T>;
        type UsizeNoHighBit = core::num::niche_types::UsizeNoHighBit;

        let $from_vec: VecU8 = _; // _1
        let $from_vec_mut_borrow: &mut VecU8 = &mut $from_vec; // _3
        let $from_vec_non_null: NonNullU8 = copy (*$from_vec_mut_borrow).buf.inner.ptr.pointer; // _16
        let $from_vec_mut_ptr: *mut u8 = copy $from_vec_non_null as *mut u8 (Transmute); // _2
        let $from_vec_immutable_borrow_1: &VecU8 = &$from_vec; // _6
        let $from_vec_cap_usize_no_high_bit: UsizeNoHighBit = copy (*$from_vec_immutable_borrow_1).buf.inner.cap; // _18
        let $from_vec_cap_usize: usize = copy $from_vec_cap_usize_no_high_bit as usize (Transmute); // _5;
        let $tsize1: usize = SizeOf($T); // _7
        let $to_vec_cap: usize = Div(move $from_vec_cap_usize, move $tsize1); // _4
        let $from_vec_immutable_borrow_2: &VecU8 = &$from_vec; // _11
        let $from_vec_len: usize = copy (*$from_vec_immutable_borrow_2).len; // _10
        let $to_vec_len_usize: usize = Div(move $from_vec_len, move $tsize2); // _9
        let $to_vec_mut_ptr: *mut $T = copy $from_vec_mut_ptr as *mut $T (PtrToPtr); // _14
        let $tsize2: usize = SizeOf($T); // _12
        let $to_vec_len_usize_no_high_bit: UsizeNoHighBit = #[Ctor] core::num::niche_types::UsizeNoHighBit(copy $to_vec_len_usize); // _21
        let $to_vec_len_usize_no_high_bit_copy: UsizeNoHighBit = copy $to_vec_len_usize_no_high_bit; // _23
        let $to_vec_const_ptr: *const u8 = copy $to_vec_mut_ptr as *const u8 (PtrToPtr);//_26
        let $to_vec_non_null: NonNullU8 = core::ptr::non_null::NonNull::<u8> {
            pointer: copy $to_vec_const_ptr
        }; // _25
        let $to_vec_unique: UniqueU8 = core::ptr::unique::Unique::<u8> {
            pointer: move $to_vec_non_null,
            _marker: const core::marker::PhantomData::<u8>
        }; // _24
        let $to_vec_raw_inner: RawVecInner = alloc::raw_vec::RawVecInner {
            ptr: move $to_vec_unique,
            cap: copy $to_vec_len_usize_no_high_bit_copy,
            alloc: const alloc::alloc::Global
        }; // _22
        let $to_vec_raw: RawVecT = alloc::raw_vec::RawVec::<$T> {
            inner: move $to_vec_raw_inner,
            _marker: const core::marker::PhantomData::<$T>
        }; // _20
        'from_raw_parts:
        let $to_vec: VecT = alloc::vec::Vec::<$T> {
            buf: move $to_vec_raw,
            len: copy $to_vec_cap
        }; // _0
    }
    
    p_t_to_u8_misordered_para[
        $T: type
    ] = fn _ (..) -> _ {
        type VecU8 = alloc::vec::Vec::<u8>;
        type VecT = alloc::vec::Vec::<$T>;
        type NonNullU8 = core::ptr::non_null::NonNull::<u8>;
        type UniqueU8 = core::ptr::unique::Unique::<u8>;
        type RawVecInner = alloc::raw_vec::RawVecInner;
        type RawVecU8 = alloc::raw_vec::RawVec::<u8>;
        type UsizeNoHighBit = core::num::niche_types::UsizeNoHighBit;

        let $from_vec: VecT = _; // _1
        let $from_vec_mut_borrow: &mut VecT = &mut $from_vec; // _3
        let $from_vec_non_null: NonNullU8 = copy (*$from_vec_mut_borrow).buf.inner.ptr.pointer; // _13
        let $from_vec_mut_ptr: *mut $T = copy $from_vec_non_null as *mut $T (Transmute); // _2
        let $from_vec_immutable_borrow_1: &VecT = &$from_vec; // _6
        let $from_vec_cap_usize_no_high_bit: UsizeNoHighBit = copy (*$from_vec_immutable_borrow_1).buf.inner.cap; // _18
        let $from_vec_cap_usize: usize = copy $from_vec_cap_usize_no_high_bit as usize (Transmute); // _5;
        let $tsize1: usize = SizeOf($T); // _7
        let $to_vec_cap: usize = Mul(move $from_vec_cap_usize, move $tsize1); // _4
        let $from_vec_immutable_borrow_2: &VecT = &$from_vec; // _10
        let $from_vec_len: usize = copy (*$from_vec_immutable_borrow_2).len; // _9
        let $tsize2: usize = SizeOf($T); // _11
        let $to_vec_len_usize: usize = Mul(move $from_vec_len, move $tsize2); // _8
        let $to_vec_mut_ptr: *mut u8 = copy $from_vec_mut_ptr as *mut u8 (PtrToPtr); // _12
        let $to_vec_len_usize_no_high_bit: UsizeNoHighBit = #[Ctor] core::num::niche_types::UsizeNoHighBit(copy $to_vec_len_usize); // _18
        let $to_vec_const_ptr: *const u8 = copy $to_vec_mut_ptr as *const u8 (PtrToPtr);//_22
        let $to_vec_non_null: NonNullU8 = core::ptr::non_null::NonNull::<u8> {
            pointer: copy $to_vec_const_ptr
        }; // _21
        let $to_vec_unique: UniqueU8 = core::ptr::unique::Unique::<u8> {
            pointer: move $to_vec_non_null,
            _marker: const core::marker::PhantomData::<u8>
        }; // _20
        let $to_vec_raw_inner: RawVecInner = alloc::raw_vec::RawVecInner {
            ptr: move $to_vec_unique,
            cap: copy $to_vec_len_usize_no_high_bit,
            alloc: const alloc::alloc::Global
        }; // _19
        let $to_vec_raw: RawVecU8 = alloc::raw_vec::RawVec::<u8> {
            inner: move $to_vec_raw_inner,
            _marker: const core::marker::PhantomData::<u8>
        }; // _17
        'from_raw_parts:
        let $to_vec: VecU8 = alloc::vec::Vec::<u8> {
            buf: move $to_vec_raw,
            len: copy $to_vec_cap
        }; // _0
    }
}

diag {
    p_u8_to_t_misordered_para = {
        primary(from_raw_parts) = "misordered parameters `len` and `cap` in `Vec::from_raw_parts`",
        label(from_raw_parts) = "`Vec::from_raw_parts` called here",
        help(from_raw_parts) = "the correct order is `Vec::from_raw_parts(ptr, len, cap)`",
        level = "deny",
        name = "misordered_parameters",
    }

    p_t_to_u8_misordered_para = {
        primary(from_raw_parts) = "misordered parameters `len` and `cap` in `Vec::from_raw_parts`",
        label(from_raw_parts) = "`Vec::from_raw_parts` called here",
        help(from_raw_parts) = "the correct order is `Vec::from_raw_parts(ptr, len, cap)`",
        level = "deny",
        name = "misordered_parameters",
    }
}