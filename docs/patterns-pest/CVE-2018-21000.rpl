pattern CVE-2018-21000

patt {
    use alloc::vec::Vec;
    use core::ptr::non_null::NonNull;
    use core::ptr::unique::Unique;
    use alloc::raw_vec::Cap;
    // use alloc::raw_vec::RawVecInner;
    use alloc::raw_vec::RawVec;
    use alloc::alloc::Global;
    use core::marker::PhantomData;

    p_u8_to_t_misordered_para[
        $T: type
    ] = fn _ (..) -> _ {
        type VecU8 = alloc::vec::Vec::<u8>;
        type VecT = alloc::vec::Vec::<$T>;
        type NonNullU8 = core::ptr::non_null::NonNull::<u8>;
        type UniqueU8 = core::ptr::unique::Unique::<u8>;
        type RawVecInner = alloc::raw_vec::RawVecInner;
        type RawVecT = alloc::raw_vec::RawVec::<$T>;
        type UsizeNoHighBit = core::num::niche_types::UsizeNoHighBit;

        let $from_vec: VecU8 = _; // _1
        let $from_vec_mut_borrow: &mut VecU8; // _3
        let $from_vec_non_null: NonNullU8; // _16
        let $from_vec_mut_ptr: *mut u8; // _2
        let $from_vec_immutable_borrow_1: &VecU8; // _6
        let $from_vec_cap_usize_no_high_bit: UsizeNoHighBit; // _18
        let $from_vec_cap_usize: usize; // _5;
        let $tsize1: usize; // _7
        let $to_vec_cap: usize; // _4
        let $from_vec_immutable_borrow_2: &VecU8; // _11
        let $from_vec_len: usize; // _10
        let $to_vec_len_usize: usize; // _9
        let $to_vec_mut_ptr: *mut $T; // _14
        let $tsize2: usize; // _12
        let $to_vec_len_usize_no_high_bit: UsizeNoHighBit; // _21
        let $to_vec_len_usize_no_high_bit_copy: UsizeNoHighBit; // _23
        let $to_vec_const_ptr: *const u8;//_26
        let $to_vec_non_null: NonNullU8; // _25
        let $to_vec_unique: UniqueU8; // _24
        let $to_vec_raw_inner: RawVecInner; // _22
        let $to_vec_raw: RawVecT; // _20
        let $to_vec: VecT; // _0

        $from_vec_mut_borrow = &mut $from_vec;
        $from_vec_non_null = copy (*$from_vec_mut_borrow).buf.inner.ptr.pointer;
        $from_vec_mut_ptr = copy $from_vec_non_null as *mut u8 (Transmute);
        $from_vec_immutable_borrow_1 = &$from_vec;
        $from_vec_cap_usize_no_high_bit = copy (*$from_vec_immutable_borrow_1).buf.inner.cap;
        $from_vec_cap_usize = copy $from_vec_cap_usize_no_high_bit as usize (Transmute);
        $tsize1 = SizeOf($T);
        $to_vec_cap = Div(move $from_vec_cap_usize, move $tsize1);
        $from_vec_immutable_borrow_2 = &$from_vec;
        $from_vec_len = copy (*$from_vec_immutable_borrow_2).len;
        $tsize2 = SizeOf($T);
        $to_vec_len_usize = Div(move $from_vec_len, move $tsize2);
        $to_vec_mut_ptr = copy $from_vec_mut_ptr as *mut $T (PtrToPtr);
        $to_vec_len_usize_no_high_bit = #[Ctor] core::num::niche_types::UsizeNoHighBit(copy $to_vec_len_usize);
        $to_vec_len_usize_no_high_bit_copy = copy $to_vec_len_usize_no_high_bit;
        $to_vec_const_ptr = copy $to_vec_mut_ptr as *const u8 (PtrToPtr);
        $to_vec_non_null = core::ptr::non_null::NonNull::<u8> {
            pointer: copy $to_vec_const_ptr
        };
        $to_vec_unique = core::ptr::unique::Unique::<u8> {
            pointer: move $to_vec_non_null,
            _marker: const core::marker::PhantomData::<u8>
        };
        $to_vec_raw_inner = alloc::raw_vec::RawVecInner {
            ptr: move $to_vec_unique,
            cap: copy $to_vec_len_usize_no_high_bit_copy,
            alloc: const alloc::alloc::Global
        };
        $to_vec_raw = alloc::raw_vec::RawVec::<$T> {
            inner: move $to_vec_raw_inner,
            _marker: const core::marker::PhantomData::<$T>
        };
        'from_raw_parts:
        $to_vec = alloc::vec::Vec::<$T> {
            buf: move $to_vec_raw,
            len: copy $to_vec_cap
        };
    }
    
    p_t_to_u8_misordered_para[
        $T: type
    ] = fn _ (..) -> _ {
        type VecU8 = alloc::vec::Vec::<u8>;
        type VecT = alloc::vec::Vec::<$T>;
        type NonNullU8 = core::ptr::non_null::NonNull::<u8>;
        type UniqueU8 = core::ptr::unique::Unique::<u8>;
        type RawVecInner = alloc::raw_vec::RawVecInner;
        type RawVecU8 = alloc::raw_vec::RawVec::<u8>;
        type UsizeNoHighBit = core::num::niche_types::UsizeNoHighBit;

        let $from_vec: VecT = _; // _1
        let $from_vec_mut_borrow: &mut VecT; // _3
        let $from_vec_non_null: NonNullU8; // _13
        let $from_vec_mut_ptr: *mut $T; // _2
        let $from_vec_immutable_borrow_1: &VecT; // _6
        let $from_vec_cap_usize_no_high_bit: UsizeNoHighBit; // _18
        let $from_vec_cap_usize: usize; // _5;
        let $tsize1: usize; // _7
        let $to_vec_cap: usize; // _4
        let $from_vec_immutable_borrow_2: &VecT; // _10
        let $from_vec_len: usize; // _9
        let $to_vec_len_usize: usize; // _8
        let $to_vec_mut_ptr: *mut u8; // _12
        let $tsize2: usize; // _11
        let $to_vec_len_usize_no_high_bit: UsizeNoHighBit; // _18
        let $to_vec_const_ptr: *const u8;//_22
        let $to_vec_non_null: NonNullU8; // _21
        let $to_vec_unique: UniqueU8; // _20
        let $to_vec_raw_inner: RawVecInner; // _19
        let $to_vec_raw: RawVecU8; // _17
        let $to_vec: VecU8; // _0


        $from_vec_mut_borrow = &mut $from_vec;
        $from_vec_non_null = copy (*$from_vec_mut_borrow).buf.inner.ptr.pointer;
        $from_vec_mut_ptr = copy $from_vec_non_null as *mut $T (Transmute);
        $from_vec_immutable_borrow_1 = &$from_vec;
        $from_vec_cap_usize_no_high_bit = copy (*$from_vec_immutable_borrow_1).buf.inner.cap;
        $from_vec_cap_usize = copy $from_vec_cap_usize_no_high_bit as usize (Transmute);
        $tsize1 = SizeOf($T);
        $to_vec_cap = Mul(move $from_vec_cap_usize, move $tsize1);
        $from_vec_immutable_borrow_2 = &$from_vec;
        $from_vec_len = copy (*$from_vec_immutable_borrow_2).len;
        $tsize2 = SizeOf($T);
        $to_vec_len_usize = Mul(move $from_vec_len, move $tsize2);
        $to_vec_mut_ptr = copy $from_vec_mut_ptr as *mut u8 (PtrToPtr);
        $to_vec_len_usize_no_high_bit = #[Ctor] core::num::niche_types::UsizeNoHighBit(copy $to_vec_len_usize);
        $to_vec_const_ptr = copy $to_vec_mut_ptr as *const u8 (PtrToPtr);
        $to_vec_non_null = core::ptr::non_null::NonNull::<u8> {
            pointer: copy $to_vec_const_ptr
        };
        $to_vec_unique = core::ptr::unique::Unique::<u8> {
            pointer: move $to_vec_non_null,
            _marker: const core::marker::PhantomData::<u8>
        };
        $to_vec_raw_inner = alloc::raw_vec::RawVecInner {
            ptr: move $to_vec_unique,
            cap: copy $to_vec_len_usize_no_high_bit,
            alloc: const alloc::alloc::Global
        };
        $to_vec_raw = alloc::raw_vec::RawVec::<u8> {
            inner: move $to_vec_raw_inner,
            _marker: const core::marker::PhantomData::<u8>
        };
        'from_raw_parts:
        $to_vec = alloc::vec::Vec::<u8> {
            buf: move $to_vec_raw,
            len: copy $to_vec_cap
        };
    }
}

diag {
    p_u8_to_t_misordered_para = {
        primary(from_raw_parts) = "misordered parameters `len` and `cap` in `Vec::from_raw_parts`",
        label(from_raw_parts) = "`Vec::from_raw_parts` called here",
        help(from_raw_parts) = "the correct order is `Vec::from_raw_parts(ptr, len, cap)`",
        level = "deny",
        name = "misordered_parameters",
    }

    p_t_to_u8_misordered_para = {
        primary(from_raw_parts) = "misordered parameters `len` and `cap` in `Vec::from_raw_parts`",
        label(from_raw_parts) = "`Vec::from_raw_parts` called here",
        help(from_raw_parts) = "the correct order is `Vec::from_raw_parts(ptr, len, cap)`",
        level = "deny",
        name = "misordered_parameters",
    }
}