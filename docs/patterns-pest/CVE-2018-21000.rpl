pattern CVE-2018-21000

patt {
    use alloc::vec::Vec;
    use core::ptr::non_null::NonNull;
    use core::ptr::unique::Unique;
    use alloc::raw_vec::Cap;
    use alloc::raw_vec::RawVecInner;
    use alloc::raw_vec::RawVec;
    use alloc::alloc::Global;
    use core::marker::PhantomData;
    use core::num::niche_types::UsizeNoHighBit;

    p_u8_to_t_misordered_para[
        $T: type
    ] = fn _ (..) -> _ {
        let $from_vec: Vec::<u8> = _; // _1
        let $from_vec_mut_borrow: &mut Vec::<u8> = &mut $from_vec; // _3
        let $from_vec_non_null: NonNull::<u8> = copy (*$from_vec_mut_borrow).buf.inner.ptr.pointer; // _16
        let $from_vec_mut_ptr: *mut u8 = copy $from_vec_non_null as *mut u8 (Transmute); // _2
        let $from_vec_immutable_borrow_1: &Vec::<u8> = &$from_vec; // _6
        let $from_vec_cap_usize_no_high_bit: UsizeNoHighBit = copy (*$from_vec_immutable_borrow_1).buf.inner.cap; // _18
        let $from_vec_cap_usize: usize = copy $from_vec_cap_usize_no_high_bit as usize (Transmute); // _5;
        let $tsize1: usize = SizeOf($T); // _7
        let $to_vec_cap: usize = Div(move $from_vec_cap_usize, move $tsize1); // _4
        let $from_vec_immutable_borrow_2: &Vec::<u8> = &$from_vec; // _11
        let $from_vec_len: usize = copy (*$from_vec_immutable_borrow_2).len; // _10
        let $tsize2: usize = SizeOf($T); // _12
        let $to_vec_len_usize: usize = Div(move $from_vec_len, move $tsize2); // _9
        let $to_vec_mut_ptr: *mut $T = copy $from_vec_mut_ptr as *mut $T (PtrToPtr); // _14
        let $to_vec_len_usize_no_high_bit: UsizeNoHighBit = #[Ctor] UsizeNoHighBit(copy $to_vec_len_usize); // _21
        let $to_vec_len_usize_no_high_bit_copy: UsizeNoHighBit = copy $to_vec_len_usize_no_high_bit; // _23
        let $to_vec_const_ptr: *const u8 = copy $to_vec_mut_ptr as *const u8 (PtrToPtr);//_26
        let $to_vec_non_null: NonNull::<u8> = NonNull::<u8> {
            pointer: copy $to_vec_const_ptr
        }; // _25
        let $to_vec_unique: Unique::<u8> = Unique::<u8> {
            pointer: move $to_vec_non_null,
            _marker: const PhantomData::<u8>
        }; // _24
        let $to_vec_raw_inner: RawVecInner = RawVecInner {
            ptr: move $to_vec_unique,
            cap: copy $to_vec_len_usize_no_high_bit_copy,
            alloc: const Global
        }; // _22
        let $to_vec_raw: RawVec<$T> = RawVec<$T> {
            inner: move $to_vec_raw_inner,
            _marker: const PhantomData::<$T>
        }; // _20
        'from_raw_parts:
        let $to_vec: Vec::<$T> = Vec::<$T> {
            buf: move $to_vec_raw,
            len: copy $to_vec_cap
        }; // _0
    }
    
    p_t_to_u8_misordered_para[
        $T: type
    ] = fn _ (..) -> _ {
        let $from_vec: Vec::<$T> = _; // _1
        let $from_vec_mut_borrow: &mut Vec::<$T> = &mut $from_vec; // _3
        let $from_vec_non_null: NonNull::<u8> = copy (*$from_vec_mut_borrow).buf.inner.ptr.pointer; // _13
        let $from_vec_mut_ptr: *mut $T = copy $from_vec_non_null as *mut $T (Transmute); // _2
        let $from_vec_immutable_borrow_1: &Vec::<$T> = &$from_vec; // _6
        let $from_vec_cap_usize_no_high_bit: UsizeNoHighBit = copy (*$from_vec_immutable_borrow_1).buf.inner.cap; // _18
        let $from_vec_cap_usize: usize = copy $from_vec_cap_usize_no_high_bit as usize (Transmute); // _5;
        let $tsize1: usize = SizeOf($T); // _7
        let $to_vec_cap: usize = Mul(move $from_vec_cap_usize, move $tsize1); // _4
        let $from_vec_immutable_borrow_2: &Vec::<$T> = &$from_vec; // _10
        let $from_vec_len: usize = copy (*$from_vec_immutable_borrow_2).len; // _9
        let $tsize2: usize = SizeOf($T); // _11
        let $to_vec_len_usize: usize = Mul(move $from_vec_len, move $tsize2); // _8
        let $to_vec_mut_ptr: *mut u8 = copy $from_vec_mut_ptr as *mut u8 (PtrToPtr); // _12
        let $to_vec_len_usize_no_high_bit: UsizeNoHighBit = #[Ctor] UsizeNoHighBit(copy $to_vec_len_usize); // _18
        let $to_vec_const_ptr: *const u8 = copy $to_vec_mut_ptr as *const u8 (PtrToPtr);//_22
        let $to_vec_non_null: NonNull::<u8> = NonNull::<u8> {
            pointer: copy $to_vec_const_ptr
        }; // _21
        let $to_vec_unique: Unique::<u8> = Unique::<u8> {
            pointer: move $to_vec_non_null,
            _marker: const PhantomData::<u8>
        }; // _20
        let $to_vec_raw_inner: RawVecInner = RawVecInner {
            ptr: move $to_vec_unique,
            cap: copy $to_vec_len_usize_no_high_bit,
            alloc: const Global
        }; // _19
        let $to_vec_raw: RawVec::<u8> = RawVec::<u8> {
            inner: move $to_vec_raw_inner,
            _marker: const PhantomData::<u8>
        }; // _17
        'from_raw_parts:
        let $to_vec: Vec::<u8> = Vec::<u8> {
            buf: move $to_vec_raw,
            len: copy $to_vec_cap
        }; // _0
    }
}

diag {
    p_u8_to_t_misordered_para = {
        primary(from_raw_parts) = "misordered parameters `len` and `cap` in `Vec::from_raw_parts`",
        label(from_raw_parts) = "`Vec::from_raw_parts` called here",
        help(from_raw_parts) = "the correct order is `Vec::from_raw_parts(ptr, len, cap)`",
        level = "deny",
        name = "misordered_parameters",
    }

    p_t_to_u8_misordered_para = {
        primary(from_raw_parts) = "misordered parameters `len` and `cap` in `Vec::from_raw_parts`",
        label(from_raw_parts) = "`Vec::from_raw_parts` called here",
        help(from_raw_parts) = "the correct order is `Vec::from_raw_parts(ptr, len, cap)`",
        level = "deny",
        name = "misordered_parameters",
    }
}

// diag {
//     p_u8_to_t_misordered_para = {
//         primary(from_vec) = "the capacity of the vector is wrong",
//         level = "deny",
//         name = "u8_to_t_misordered_para",
//     }

//     p_t_to_u8_misordered_para = {
//         primary(from_vec) = "the capacity of the vector is wrong",
//         level = "deny",
//         name = "t_to_u8_misordered_para",
//     }
// }
