pattern CVE-2024-27284

patt {
    p_cassandra_iter_next_ptr_passed_to_cass_iter_get[
        $I: type,
        $T: type,
    ] = {
        pub fn _(..) {
            type CassIterator = cassandra_cpp_sys::CassIterator_;
            type CassBool = cassandra_cpp_sys::cass_bool_t;
            type AggregateMeta = cassandra_cpp_sys::CassAggregateMeta_;

            let $cass_mut_iter1: *mut CassIterator = _;
            'cass_iter_next:
            let $next_res: CassBool = cassandra_cpp_sys::cass_iterator_next(move $cass_mut_iter1);
            let $discr: u32 = discriminant($next_res);

            let $cass_mut_iter2: *mut CassIterator;
            let $cass_const_iter: *const CassIterator;
            let $cass_meta_ptr: *const AggregateMeta;

            switchInt(move $discr) {
                0_usize => {
                    $cass_mut_iter2 = _;
                    $cass_const_iter = move $cass_mut_iter2 as *const CassIterator (PtrToPtr);
                    $cass_meta_ptr = cassandra_cpp_sys::cass_iterator_get_aggregate_meta(move $cass_const_iter);
                }
                _ => {}
            }
        }
    }
}

diag {
    p_cassandra_iter_next_ptr_passed_to_cass_iter_get = {
        primary(cass_iter_next) = "it will be an undefined behavior to pass a pointer returned by `cass_iterator_next` to `cass_iterator_get_*` in a `std::iter::Iterator` implementation",
        label(cass_iter_next)   = "`cass_iterator_next` called here",
        note                    = "`cass_iterator_next` will invalidate the current item when called",
        help                    = "consider implementing a `LendingIterator` instead",
        level                   = "deny",
        name                    = "cassandra_iter_next_ptr_passed_to_cass_iter_get",
    }
}
