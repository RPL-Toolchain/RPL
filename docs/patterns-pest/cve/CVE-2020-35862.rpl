pattern CVE-2020-35862

patt {
    use_after_move[
        $T: type,
        $Vec: type,
    ] = {
        struct $Ptr {
            $ptr: core::ptr::NonNull<$T>,
        }

        struct $BitVec {
            $ptr: $Ptr,
        }

        fn $pattern(..) -> _ {
            let $bit_vec_1: $BitVec = _; // _1
            let $bit_ptr: $Ptr = copy ($bit_vec_1.$ptr); // _2 bb0[0]
            let $bit_vec_2: $BitVec = move $bit_vec_1; // _6 bb0[1]
            let $bit_ptr_1: &$Ptr = &($bit_vec_2.$ptr); // _8 bb0[2]
            let $non_null_1: core::ptr::NonNull<u8> = copy ((*$bit_ptr_1).$ptr); // _19 bb0[3]
            let $ptr_1: *mut u8 = copy $non_null_1 as *mut u8 (Transmute); // _18 bb0[4]
            let $addr_1: usize = move $ptr_1 as usize (PointerExposeProvenance); // _17 bb0[5]
            let $addr_2: usize = BitAnd(move $addr_1, _); // _16 bb0[6]
            // let $pointer_1: Pointer<$T> = move $ptr_1 as usize (PointerExposeProvenance); // _14
            let $ptr_2: *mut $T = _; // _13 bb0[8]
            let $ptr_mut_slice: *mut [$T] = *mut [$T] from (copy $ptr_2, _); // _20 bb2[0]
            let $ref_mut_slice: &mut [$T] = &mut (*$ptr_mut_slice); // _7 bb2[1]
            let $ptr_slice: *mut [$T] = &raw mut (*$ref_mut_slice); // _21 bb2[2]
            let $ptr_3: *mut $T = move $ptr_slice as *mut $T (PtrToPtr); // _9 bb2[3]
            let $ptr_4: *const u8 = copy $ptr_3 as *const u8 (PtrToPtr); // _28 bb3[1]
            let $non_null: core::ptr::NonNull<u8> = core::ptr::NonNull<u8> { pointer: copy $ptr_4 }; // _27 bb3[2]
            // let $non_null: core::ptr::NonNull<u8> = _; // _65
            let $unique: core::ptr::Unique<u8> = core::ptr::Unique<u8> { pointer: move $non_null, _marker: const core::marker::PhantomData::<u8> }; // _26 bb3[3]
            let $raw_vec_inner: alloc::raw_vec::RawVecInner = alloc::raw_vec::RawVecInner { ptr: move $unique, cap: _, alloc: _ }; // _24 bb3[4]
            let $raw_vec: alloc::raw_vec::RawVec<$T> = alloc::raw_vec::RawVec<$T> { inner: move $raw_vec_inner, _marker: _ }; // _22 bb3[5]
            let $vec: $Vec /* alloc::vec::Vec<$T> */ = alloc::vec::Vec<$T> { buf: move $raw_vec, len: _ }; // _5 bb3[6]
            'vec_move:
            let $boxed_slice: alloc::boxed::Box<[$T]> = alloc::vec::Vec::into_boxed_slice(move $vec); // _3 bb3[7]
            'ptr_use:
            let $non_null_2: core::ptr::NonNull<u8> = copy ($bit_ptr.$ptr); // _37 bb1[0]
        }
    }
}

diag {
    use_after_move = {
        primary(ptr_use) = "use a pointer from `{$Vec}` after it's moved",
        label(ptr_use)   = "used here",
        note(vec_move)   = "the `{$Vec}` value may be moved here",
        name             = "use_after_move",
        level            = "deny",
    }
}
