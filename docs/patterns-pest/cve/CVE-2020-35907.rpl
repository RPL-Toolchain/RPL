pattern CVE-2020-35907

patt {
    use std::thread::LocalKey;

    p_thread_local_static_ref[
        $T: type where is_sync(self),
    ] = {
        // FIXME: the return type is not actually checked to be matched
        #[output = "output"]
        pub fn _(..) -> &'static $T {
            type LocalKeyUnsafeCellT = LocalKey<std::cell::UnsafeCell<$T>>;
            'thread_local:
            let $local_key: &LocalKeyUnsafeCellT = _;
            'ret:
            let $RET: &$T = LocalKeyUnsafeCellT::with::<_, _>(move $local_key, _);
        }
    }

    #[diag = "p_thread_local_static_ref"]
    p_thread_local_static_ref_inline_100[
        $T: type where is_sync(self),
    ] = {
        // FIXME: the return type is not actually checked to be matched
        #[output = "output"]
        pub fn _(..) -> &'static $T {
            type LocalKeyUnsafeCellT = LocalKey<std::cell::UnsafeCell<$T>>;

            'thread_local:
            let $local_key: &LocalKeyUnsafeCellT = _;
            let $result: core::result::Result<&$T, _> = LocalKeyUnsafeCellT::try_with::<_, _>(move $local_key, _);

            'ret:
            let $RET: &$T = move (($result as Ok).0);
        }
    }
}

diag {
    p_thread_local_static_ref = {
        primary(output)     = "it is unsound to expose a `&'static {$T}` from a thread-local where `{$T}` is `Sync`",
        help                = "`{$T}` is `Sync` so that it can shared among threads",
        help                = "the thread local is destroyed after the thread has been destroyed, and the exposed `&'static {$T}` may outlive the thread it is exposed to",
        label(output)       = "function returning `&'static {$T}` here",
        label(thread_local) = "thread local used here",
        label(ret)          = "`&'static {$T}` returned here",
        level               = "deny",
        name                = "thread_local_static_ref",
//      note            = "this is because the thread local may be destroyed after the thread has been destroyed",
    }
}
