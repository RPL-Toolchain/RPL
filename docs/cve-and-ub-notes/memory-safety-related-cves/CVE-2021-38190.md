# CVE-2021-38190

## Metadata

- RustSec: https://rustsec.org/advisories/RUSTSEC-2021-0070.html
- Mitre: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-38190
- Bug Report GitHub Issue/Release: https://github.com/dimforge/nalgebra/issues/883
- Bug Fix GitHub Commit/PR: https://github.com/dimforge/nalgebra/pull/889

## Source

```rust
/// A Vec-based matrix data storage. It may be dynamically-sized.
#[repr(C)]
#[derive(Eq, Debug, Clone, PartialEq)]
#[cfg_attr(feature = "serde-serialize", derive(Serialize, Deserialize))]
pub struct VecStorage<T, R: Dim, C: Dim> {
    data: Vec<T>,
    nrows: R,
    ncols: C,
}
```

## Description / Analysis

The Deserialize implementation for VecStorage did not maintain the invariant that `data.len() == nrows*ncols`(there is some unsafe code that relies on this invariant). Deserialization of specially crafted inputs could allow memory access beyond allocation of the vector.

### Example

```rust
#[repr(C)]
#[derive(Eq, Debug, Clone, PartialEq)]
#[derive(Serialize, Deserialize)]
#[sf_invariant ...]
pub struct VecStorage<T> {
    data: Vec<T>,
    nrows: usize,
    ncols: usize,
}

impl<T> VecStorage<T> {
    pub unsafe fn get_unchecked(&self, row: usize, col: usize) -> &T {
        let idx = row * self.ncols + col;
        self.data.get_unchecked(idx)
    }

}

#[test]
fn f() {
    let malicious_json = r#"{
        "data": [1, 2, 3, 4, 5, 6, 7, 8],
        "nrows": 2,
        "ncols": 5
    }"#;

    let deserialized: VecStorage<i32> = serde_json::from_str(malicious_json).unwrap();

    unsafe {
        let _ = deserialized.get_unchecked(1, 4);
    }
}
```

## Fixes

Write a custom Deserialize implementation that validates the input.

## Pattern Description

TODO
