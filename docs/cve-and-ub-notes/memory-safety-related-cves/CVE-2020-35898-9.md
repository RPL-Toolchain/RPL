# CVE-2020-35858-9

## Metadata

- RustSec: https://rustsec.org/advisories/RUSTSEC-2020-0045.html
- Mitre: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-35898
- Bug Report GitHub Issue/Release: https://github.com/actix/actix-net/issues/160
- Bug Fix GitHub Commit/PR: https://github.com/actix/actix-net/pull/161

## Source

```rust
use std::cell::UnsafeCell;
use std::rc::Rc;

pub struct Cell<T> {
    pub inner: Rc<UnsafeCell<T>>,
}

impl<T> Clone for Cell<T> {
    fn clone(&self) -> Self {
        Self {
            inner: self.inner.clone(),
        }
    }
}

impl<T> Cell<T> {
    pub fn new(inner: T) -> Self {
        Self {
            inner: Rc::new(UnsafeCell::new(inner)),
        }
    }

    pub fn get_mut(&mut self) -> &mut T {
        unsafe { &mut *self.inner.as_ref().get() }
    }
}
```

## Description / Analysis

The cause of this CVE is: the custom `Cell` incorrectly couples the Rust standard library's `Rc` and `UnsafeCell`.

The developer's motivation for this CVE may be: trying to avoid the performance overhead of `RefCell`.

The fix for this CVE is: replacing all occurrences of custom `Cell` with `Rc<RefCell>`.

### `UnsafeCell`

The core primitive for interior mutability in Rust.

```rust
#[lang = "unsafe_cell"]
#[stable(feature = "rust1", since = "1.0.0")]
#[repr(transparent)]
pub struct UnsafeCell<T: ?Sized> {
    value: T,
}

impl<T: ?Sized> UnsafeCell<T> {
    #[inline(always)]
    #[stable(feature = "rust1", since = "1.0.0")]
    #[rustc_const_stable(feature = "const_unsafecell_get", since = "1.32.0")]
    #[rustc_never_returns_null_ptr]
    pub const fn get(&self) -> *mut T {
        // We can just cast the pointer from `UnsafeCell<T>` to `T` because of
        // #[repr(transparent)]. This exploits std's special status, there is
        // no guarantee for user code that this will work in future versions of the compiler!
        self as *const UnsafeCell<T> as *const T as *mut T
    }
}
```

### Bug

In the related issue, `miri` found UB in a real-world code snippet using this crate, where multiple mutable references exist simultaneously.

But we can construct a simpler case using the `get_mut` method and the `Clone` trait in the custom `Cell` to make multiple mutable references exist simultaneously:

```Rust
fn test_cell() {
    let mut cell_1 = Cell::new(String::from("value"));
    let mut cell_2 = cell_1.clone();
    let mref_1 = cell_1.get_mut();
    let mref_2 = cell_2.get_mut();
    mref_1.push_str("new");
   	println!("m2: {}", mref_2);
}
```

> Attention: If we change the implementation of `Clone` to the following form:
>
> ```rust
> impl<T:Clone> Clone for Cell<T> {
>        fn clone(&self) -> Self {
>            let new_inner_value: T = unsafe { (*self.inner.as_ref().get()).clone() };
>            Self {
>                inner: Rc::new(UnsafeCell::new(new_inner_value)),
>            }
>     }
> }
> ```
>
> , there is no undefined behavior, but `Rc` does not play its role in reference counting.

## Fixes

The fix for this CVE is: replacing all occurrences of custom `Cell` with `Rc<RefCell>`.

## Pattern Description

A public `Rc<UnsafeCell<T>>` and a "normally" implemented clone method.

````rpl
pattern CVE-2020-35898-9

mvar {
    T: ty
    Cell: adt
    inner: field
    get_mut: span
    body: span
}

util {
    p_struct = pub adt $Cell {
        self.**.$inner: Rc<UnsafeCell<$T>>,
    }

    p_clone = impl Clone for $Cell {
        fn clone(&self) -> Self {
            Self {
                $inner: self.$inner.clone(),
            }
        }
    }

    p_get_mut = impl $Cell {
        #span![get_mut]
        pub fn _(&mut self) -> &mut $T {
            unsafe { #span!($body, &mut *self.$inner.as_ref().get()) }
        }
    }
}

patt {
    p: err =
        & p_struct 
        & p_clone 
        & p_get_mut => AliasMut {
            $get_mut,
            $body,
        }
}

use {
    std::cell::UnsafeCell
    std::cell::Cell
    std::rc::Rc
}

diag {
    #[derive(Diagnostic)]
    #[diag(alias_mut)]
    pub struct AliasMut {
        pub get_mut: Span,
        #[label]
        pub body: Span,
    }
}

msg {
    alias_mut = return a mutable reference that can alias
        .label = mutable reference from the pointer returned by `UnsafeCell::get`
}

````

