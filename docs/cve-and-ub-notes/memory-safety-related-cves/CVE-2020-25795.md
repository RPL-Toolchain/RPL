# CVE-2020-25795

## Metadata

- RustSec: https://rustsec.org/advisories/RUSTSEC-2020-0041.html
- Mitre: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-25795
- Bug Report GitHub Issue/Release: https://github.com/bodil/sized-chunks/issues/11
- Bug Fix GitHub Commit/PR: https://github.com/bodil/sized-chunks/pull/15

> An issue was discovered in the sized-chunks crate through 0.6.2 for Rust. In the Chunk implementation,insert_from can have a memory-safety issue upon a panic.

## Source

The code of `insert_from`:

```rust
pub fn insert_from<Iterable, I>(&mut self, index: usize, iter: Iterable)
    where
        Iterable: IntoIterator<Item = A, IntoIter = I>,
        I: ExactSizeIterator<Item = A>,
{
    let iter = iter.into_iter();
    let insert_size = iter.len();
    if self.len() + insert_size > Self::CAPACITY {
        panic!(
            "Chunk::insert_from: chunk cannot fit {} elements",
            insert_size
        );
    }
    if index > self.len() {
        panic!("Chunk::insert_from: index out of bounds");
    }
    let real_index = index + self.left;
    let left_size = index;
    let right_size = self.right - real_index;
    if self.right == N::USIZE || (self.left >= insert_size && left_size < right_size) {
        unsafe {
            Chunk::force_copy(self.left, self.left - insert_size, left_size, self);
            let mut write_index = real_index - insert_size;
            for value in iter {
                Chunk::force_write(write_index, value, self);
                write_index += 1;
            }
        }
        self.left -= insert_size;
    } else if self.left == 0 || (self.right + insert_size <= Self::CAPACITY) {
        unsafe {
            Chunk::force_copy(real_index, real_index + insert_size, right_size, self);
            let mut write_index = real_index;
            for value in iter {
                Chunk::force_write(write_index, value, self);
                write_index += 1;
            }
        }
        self.right += insert_size;
    } else {
        unsafe {
            Chunk::force_copy(self.left, 0, left_size, self);
            Chunk::force_copy(real_index, left_size + insert_size, right_size, self);
            let mut write_index = left_size;
            for value in iter {
                Chunk::force_write(write_index, value, self);
                write_index += 1;
            }
        }
        self.right -= self.left;
        self.right += insert_size;
        self.left = 0;
    }
}
```

The way to trigger the panic is to pass an Panicking iterator to `insert_from`, see the issue.

## Description / Analysis

Invariants: Properties that must always hold.

The safety invariant is an invariant that safe code may assume all data to uphold. 

```rust
pub struct RingBuffer<A, N = U64>
where
    N: ChunkLength<A>,
{
    origin: RawIndex<N>,
    length: usize,
    data: MaybeUninit<N::SizedType>,
}

impl<A, N: ChunkLength<A>> Drop for RingBuffer<A, N> {
    #[inline]
    fn drop(&mut self) {
        if core::mem::needs_drop::<A>() {
            for i in self.range() {
                unsafe {
                    self.force_drop(i)
                }
            }
        }
    }
}
```

The safety invariant is that: The data which is in the range of `self.range()` can be read/written/dropped(from `for i in self.range() force_drop...`). In normal cases, after the `insert_from` and `clone` functions, the safety invariant is maintained.

However, `insert_from` and `clone` functions write elements one by one (where the writing elements of `insert_from` are generated by `iter.next()`, and the writing elements of `clone` are generated by `A::clone`), 
but before all elements are successfully written, there will be some "holes" in the Ringbuffer (invalid values that cannot be read, written, or dropped). If a panic occurs in one of the `iter.next()` or `clone` ,it will immediately trigger an unwind and release the objects in the stack frame one by one. At this time, the RingBuffer has not completely restored the invariant, so the invariant that the drop relies on is incorrect, releasing elements that should not be released, resulting in double free.


## Fixes

TODO

## Pattern Description

TODO

## References

- Two-kinds-of-invariants: https://www.ralfj.de/blog/2018/08/22/two-kinds-of-invariants.html
- Unsafe Code Guideline: https://rust-lang.github.io/unsafe-code-guidelines/glossary.html
- 