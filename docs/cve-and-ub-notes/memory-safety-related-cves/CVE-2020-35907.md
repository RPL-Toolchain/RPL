> A link to an encrypted external resource: https://www.yuque.com/frankking/wceyqq/xgns3c780gdfoqk6

# CVE-2020-35907

## Metadata

- RustSec: https://rustsec.org/advisories/RUSTSEC-2020-0061.html
- Mitre: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-35907
- Bug Report GitHub Issue/Release: https://github.com/rust-lang/futures-rs/issues/2091  
- Bug Fix GitHub Commit/PR: https://github.com/rust-lang/futures-rs/pull/2095

## Source

```rust
use core::task::{RawWaker, RawWakerVTable, Waker};
use std::cell::UnsafeCell;

fn noop_waker() -> Waker {
    // just let Copilot/Gpt generate a naive noop waker
}

pub fn noop_waker_ref() -> &'static Waker {
    thread_local! {
        static NOOP_WAKER_INSTANCE: UnsafeCell<Waker> =
            UnsafeCell::new(noop_waker());
    }
    NOOP_WAKER_INSTANCE.with(|l| unsafe { &*l.get() })
}
```

The code that triggers the vulnerability is as follows:

```rust
use futures::task::noop_waker_ref;
fn main() {
    let waker = std::thread::spawn(|| noop_waker_ref()).join().unwrap();
    waker.wake_by_ref();
}
```

## Description / Analysis

`noop_waker_ref()` returns a `'static` reference into TLS, but `Waker` is `Sync` so `&'static Waker` is `Send`, allowing the reference to outlive the thread it came from, causing a use-after-free.

## Fixes

Use `once_cell`.

```rust
pub fn noop_waker_ref() -> &'static Waker {
    static NOOP_WAKER_INSTANCE: Lazy<Waker> = Lazy::new(noop_waker);
    &*NOOP_WAKER_INSTANCE
}
```

## Pattern Description

- Use a thread-local object
- get a `&'static T` reference to it
- `T` is `Sync`

````rpl
pattern CVE-2020-35907

mvar {
    T: ty
    T_UNSAFE_CELL_INSTANCE: ident
    thread_local: span
    expr: span
}

util {
    pat_unsafe_cell = fn _(_) -> &'static $T 
    where 
        $T: Sync
    {
        const #span!($thread_local, $T_UNSAFE_CELL_INSTANCE): ::std::thread::LocalKey<UnsafeCell<$T>> = _;
        unsafe { #span!($expr, $T_UNSAFE_CELL_INSTANCE.with(|unsafe_cell| &*unsafe_cell.get())) }
    }
}

use {
    std::cell::UnsafeCell
}

patt {
    p: err = pat_unsafe_cell => DanglingThreadLocal {
        $expr,
        $thread_local
    }
}

diag {
    #[derive(Diagnostic)]
    #[diag(dangling_thread_local)]
    pub struct DanglingThreadLocal {
        #[primary_span]
        pub expr: Span,
        #[help]
        pub thread_local: Span,
    }
}

msg {
    dangling_thread_local = the `'static` reference to thread local can outlive the thread it belongs to
        .help = try `std::cell::OnceCell` instead
}
````

## References

- LocalKey: https://doc.rust-lang.org/std/thread/struct.LocalKey.html
