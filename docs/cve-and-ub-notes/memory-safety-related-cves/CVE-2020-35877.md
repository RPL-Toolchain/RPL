# CVE-2020-35877

## Metadata

- RustSec: https://rustsec.org/advisories/RUSTSEC-2020-0022.html
- Mitre: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-35877
- Bug Report GitHub Issue/Release: \_
- Bug Fix GitHub Commit/PR: \_

## Source

```rust
use memmap::{Mmap, Protection};

/// A buffer that is backed by an anonymous memory map.
///
/// **Anonymously** means that the memory is not backed by a file.
pub struct AnonymousBuffer<T>
    where T: Sized
{
    data: Arc<Mutex<Mmap>>,
    phantom: PhantomData<T>,
}

impl<T> AnonymousBuffer<T>
    where T: Sized
{
    /// Create a new anonymous buffer of the given size.
    pub fn try_new(size: usize) -> Result<Self>
    {
        let map = Mmap::anonymous(size, Protection::ReadWrite)?;
        Ok(Self { data: Arc::new(Mutex::new(map)), phantom: PhantomData })
    }
}

impl<T> Index<usize> for AnonymousBuffer<T>
    where T: Sized
{
    type Output = T;

    fn index(&self, idx: usize) -> &Self::Output {
        unsafe {
            let mut count = idx;
            let mut p: *const T = self.data.lock().unwrap().ptr() as *const T;
            while count > 0 {
                count -= 1;
                p = p.offset(1);
            }
            &*p
        }
    }
}

fn main() {
    let buf = AnonymousBuffer::<u8>::try_new(1024).unwrap();
    println!("{:?}", &buf[1024]);
}
```

## Description / Analysis

Lack of bounds checking in the `index` method of the `AnonymousBuffer` struct allows an attacker to read memory outside the bounds of the buffer. This can lead to information disclosure or other security vulnerabilities.

However, the `AnonymousBuffer` struct is not a public struct. It is not clear whether and how an attacker can exploit this vulnerability.

## Fixes

TODO

## Pattern Description
