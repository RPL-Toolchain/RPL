# CVE-2021-45707

## Metadata

- RustSec: https://rustsec.org/advisories/RUSTSEC-2021-0119.html
- Mitre: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-45707
- Bug Report GitHub Issue/Release: https://github.com/nix-rust/nix/issues/1541
- Bug Fix GitHub Commit/PR: https://github.com/nix-rust/nix/pull/1545

## Source

```rust
pub fn getgrouplist(user: &CStr, group: Gid) -> Result<Vec<Gid>> {
    let ngroups_max = match sysconf(SysconfVar::NGROUPS_MAX) {
        Ok(Some(n)) => n as c_int,
        Ok(None) | Err(_) => <c_int>::max_value(),
    };
    use std::cmp::min;
    let mut ngroups = min(ngroups_max, 8);
    let mut groups = Vec::<Gid>::with_capacity(ngroups as usize);
    cfg_if! {
        if #[cfg(any(target_os = "ios", target_os = "macos"))] {
            type getgrouplist_group_t = c_int;
        } else {
            type getgrouplist_group_t = gid_t;
        }
    }
    let gid: gid_t = group.into();
    loop {
        let ret = unsafe {
            libc::getgrouplist(user.as_ptr(),
                               gid as getgrouplist_group_t,
                               groups.as_mut_ptr() as *mut getgrouplist_group_t,
                               &mut ngroups)
        };

        // BSD systems only return 0 or -1, Linux returns ngroups on success.
        if ret >= 0 {
            unsafe { groups.set_len(ngroups as usize) };
            return Ok(groups);
        } else if ret == -1 {
            // Returns -1 if ngroups is too small, but does not set errno.
            // BSD systems will still fill the groups buffer with as many
            // groups as possible, but Linux manpages do not mention this
            // behavior.
            reserve_double_buffer_size(&mut groups, ngroups_max as usize)
                .map_err(|_| Errno::EINVAL)?;
        }
    }
}
```

## Description / Analysis

```c
int getgrouplist(const char *user, gid_t group,
                gid_t *groups, int *ngroups);
```

The getgrouplist() function scans the group database (see group(5)) to obtain the list of groups that user belongs to. Up to \*ngroups of these groups are returned in the array groups.

If the number of groups of which user is a member is less than or equal to `*ngroups`, then the value `*ngroups` is returned.

**If the user is a member of more than `*ngroups` groups, then getgrouplist() returns -1. In this case, the value returned in `*ngroups` can be used to resize the buffer passed to a further call to getgrouplist().**

Now assume that user is a member of 16 groups.

- The first call to getgrouplist() will return -1 and set `*ngroups` to 16.
- The buffer passed to the first call's capacity will be doubled, let us say 4\*2 = 8.
- The second call to getgrouplist() will write 16 groups to the buffer, which is of capacity 8. This will result in a out-of-bounds write.

## Fixes

At the beginning of every loop, `let mut ngroups = groups.capacity() as i32;`.

## Pattern Description

More like a safety requirement, before calling `libc::getgrouplist`, `buf.capacity() >= ngroups` should be ensured.

## References

- [getgrouplist](https://man7.org/linux/man-pages/man3/getgrouplist.3.html)
