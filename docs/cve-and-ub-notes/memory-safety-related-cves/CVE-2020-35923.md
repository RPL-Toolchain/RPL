# CVE-2020-35923

## Metadata

- RustSec: https://rustsec.org/advisories/RUSTSEC-2020-0082.html
- Mitre: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-35923
- Bug Report GitHub Issue/Release: https://github.com/reem/rust-ordered-float/pull/71
- Bug Fix GitHub Commit/PR: https://github.com/reem/rust-ordered-float/pull/71/commits/7b5c8fe6b684239213e7e3e9d74c3dfc12599f16

## Source

```rust
/// A wrapper around floats providing an implementation of Eq, Ord and Hash.
/// A NaN value cannot be stored in this type.
pub struct NotNan<T>(T);
```

```rust
impl<T: Float + AddAssign> AddAssign<T> for NotNan<T> {
    fn add_assign(&mut self, other: T) {
        self.0 += other;
        assert!(!self.0.is_nan(), "Addition resulted in NaN");
    }
}
```

## Fixes - "Make assignment operators panic safe"

```rust
impl<T: Float + AddAssign> AddAssign<T> for NotNan<T> {
    fn add_assign(&mut self, other: T) {
        *self = *self + other;
    }
}
```

## Description / Analysis

### Before Fix

```rust
impl<T: Float + AddAssign> AddAssign<T> for NotNan<T> {
    fn add_assign(&mut self, other: T) {
        self.0 += other;
        assert!(!self.0.is_nan(), "Addition resulted in NaN");
    }
}
```

(1) The `+=` operator used in line 3 is provided by the `AddAssign` trait, which is implemented by the type `T`.

(2) `self.0` is modified prior to the assertion check in line 4, which means that if the addition operation results in a NaN, the value of `self.0` will be NaN.

(3) line 4 will panic if the addition operation results in a NaN.

```rust
#[test]
fn not_nan_panic_safety() {
    fn not_nan<T: Float>(x: T) -> NotNan<T> {
        NotNan::new(x).unwrap()
    }

    fn catch_op(mut num: NotNan<f64>, op: fn(&mut NotNan<f64>)) -> NotNan<f64> {
        let mut num_ref = std::panic::AssertUnwindSafe(&mut num);
        let _ = std::panic::catch_unwind(move || op(*num_ref));
        num
    }

    let x = catch_op(not_nan(f64::INFINITY), |a| *a += f64::NEG_INFINITY);
    let y = not_nan(1.0_f64);
    let _ = x.cmp(&y);
}
```

(4) The unwinding process after the panic could be caught, the program may recover from this exception and continue executing, potentially leaving the value inside `NotNan` in an invalid state, i.e., NaN.

```rust
impl<T: Float> Ord for NotNan<T> {
    fn cmp(&self, other: &NotNan<T>) -> Ordering {
        match self.partial_cmp(&other) {
            Some(ord) => ord,
            None => unsafe { std::hint::unreachable_unchecked() },
        }
    }
}
```

(5) The safe `NotNan::cmp` method contains internal unsafe code that assumes the value is never NaN, reaching ` std::hint::unreachable_unchecked` is undefined behavior.

> ```rust
> pub const unsafe fn unreachable_unchecked() -> ! {
> 	ub_checks::assert_unsafe_precondition!(
>     	check_language_ub,
>     	"hint::unreachable_unchecked must never be reached",
>     	() => false
>  	);
>  	// SAFETY: the safety contract for `intrinsics::unreachable` must
>  	// be upheld by the caller.
>  	unsafe { intrinsics::unreachable() }
> }
> ```

### After Fix

```rust
impl<T: Float + AddAssign> AddAssign<T> for NotNan<T> {
    fn add_assign(&mut self, other: T) {
        *self = *self + other;
    }
}
```

(1) The `+` operator in line 3 is provided by the `Add` trait, which is implemented by `NotNan<T>`.

```rust
impl<T: Float> Add<T> for NotNan<T> {
    type Output = Self;

    fn add(self, other: T) -> Self {
        NotNan::new(self.0 + other).expect("Addition resulted in NaN")
    }
}

impl<T: Float> NotNan<T> {
    pub fn new(val: T) -> Result<Self, FloatIsNan> {
        match val {
            ref val if val.is_nan() => Err(FloatIsNan),
            val => Ok(NotNan(val)),
        }
    }
}
```

(2) A new `NotNan` instance is created in line 5, so the original value is not modified if the addition operation results in a NaN.

## Pattern Description

TODO

## References

`std::hint::unreachable_unchecked`: https://doc.rust-lang.org/std/hint/fn.unreachable_unchecked.html
