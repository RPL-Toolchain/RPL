# CVE-2020-35892-3

## Metadata

- RustSec: https://rustsec.org/advisories/RUSTSEC-2020-0039.html
- Mitre: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-35892
- Bug Report GitHub Issue/Release: https://github.com/nathansizemore/simple-slab/issues/2
- Bug Fix GitHub Commit/PR: [TODO](https://github.com/nathansizemore/simple-slab/commit/5e0524c1db836e2192e1cd818848d96937c0b587)

## Source

```rust
impl<T> Index<usize> for Slab<T> {
    type Output = T;
    fn index(&self, index: usize) -> &Self::Output {
        unsafe { &(*(self.mem.offset(index as isize))) }
    }
}
```

```rust
#[inline]
pub fn remove(&mut self, offset: usize) -> T {
    assert!(offset < self.len, "Offset out of bounds");

    let elem: T;
    let last_elem: T;
    let elem_ptr: *mut T;
    let last_elem_ptr: *mut T;

    unsafe {
        elem_ptr = self.mem.offset(offset as isize);
        last_elem_ptr = self.mem.offset(self.len as isize);

        elem = ptr::read(elem_ptr);
        last_elem = ptr::read(last_elem_ptr);

        ptr::write(elem_ptr, last_elem);
    }

    self.len -= 1;
    return elem;
}
```

## Description / Analysis

- Slab::index() does not perform the boundary checking, which leads to out-of-bound read access.
- Slab::remove() copies an element from an invalid address due to off-by-one error, resulting in memory leakage and uninitialized memory drop.

## Fixes

For first,

```rust
assert!(index < self.len, "Index out of bounds");
```

For second,

```rust
last_elem_ptr = self.mem.offset((self.len - 1) as isize);
```

## Pattern Description

````rpl
pattern CVE-2020-35892-3

mvar {
    S: adt
    self: ident
    T: ty
    len: field
    ptr: field
    index: ident
    self_len: span
}

util {
    pat_struct = pub adt $S {
        self.**.$ptr: *mut $T,
        self.**.$len: usize,
    }

    p_drop_slice = impl Drop for $S {
        fn drop(&mut self) {
            let slice: *mut [$T] = core::ptr::slice_from_raw_parts_mut(self.$ptr, self.$len);
            unsafe { drop_in_place(slice) };
        }
    }

    p_drop_loop = impl Drop for $S {
        fn drop(&mut self) {
            for i in 0..self.$len {
                let ptr: *mut $T = self.$ptr.add(i);
                unsafe { drop_in_place(slice) };
            }
        }
    }

    pat_index = ?pub ?unsafe fn _(_) -> _ {
        let $self: &$S = _;
        let $index: usize = _;
        #without!(if $index < #span!($self_len, $self.$len)) {
            let ptr: *mut $T = $self.$ptr.add(index);
            unsafe { #span!($access_ptr, #access!(ptr)) };
        }
    }

    pat_off_by_one = ?pub ?unsafe fn _(...) -> $(_) {
        let $self: &$S = _;
        let ptr: *mut $T = $self.$ptr.add(self.$len);
        unsafe { #span!($access_ptr, #access!(ptr)) };
    }
}

patt {
    p_index: err = & pat_struct
        & (pat_drop_slice | pat_drop_loop)
        & pat_index => IndexOverflow {
            $access_ptr,
            init_span: $access_ptr.shrink_to_lo(),
            self_len: snippet($self_len),
            $index,
        }
    p_off_by_one: err = & pat_struct
        & (pat_drop_slice | pat_drop_loop)
        & pat_off_by_one => OffsetByOneError {
            $access_ptr,
        }
}

use {
    core::ptr::drop_in_place
}

diag {
    #[derive(Diagnostic)]
    #[diag(index_overflow)]
    pub struct IndexOverflow {
        #[primary_span]
        pub access_ptr: Span,
        #[suggestion(code = "assert!({index} < {self_len});")]
        pub init_span: Span,
        pub self_len: String,
        pub index: Ident,
    }

    #[derive(Diagnostic)]
    #[diag(off_by_one_error)]
    pub struct OffByOneError {
        #[primary_span]
        pub access_ptr: Span,
    }
}

msg {
    index_overflow = access an overflowing pointer
        .suggestion = try asserting `{$index}` in bound

    off_by_one = access an off-by-one pointer
}
````

## Subgraph Isomorphism
### MIR Code
#### Pattern Code
```rust
p_drop (Slab: ident, len: ident, mem: ident) = fn drop(self: &mut $Slab) { #mir! {
    let len: usize; // _2
    let mut x0: usize; // _17
    let x1: usize; // _14
    let x2: usize; // _15
    let x3: Option<usize>; // _3
    let x: usize; // _4
    let mut base: *mut T; // _6
    let offset: isize; // _7
    let elem_ptr: *mut T; // _5
    let x_cmp: usize; // _16
    let cmp: bool; // _13
    
    len = copy (*self).$len;
    x0 = const 0_usize;
    loop {
        x_cmp = copy x0;
        cmp = Lt(move x_cmp, copy len);
        switchInt(move cmp) {
            0 => break,
            _ => {
                x1 = copy x0;
                x2 = forward_unchecked(copy x1, const 1_usize);
                x0 = move x2;
                x3 = Some(copy x1);
                x = copy (x3 as Some).0;
                base = copy (*self).$mem;
                offset = copy x as isize (IntToInt);
                elem_ptr = Offset(copy base, copy offset);
                _ = drop_in_place(copy elem_ptr);
            }
        }
    }
} }
```

#### Target Code
```rust
fn drop(_1: &mut Slab<T>) -> () {
    debug self => _1;
    let mut _0: ();
    let mut _2: usize; // iter.1
    let mut _3: std::option::Option<usize>;
    let mut _6: *mut T;
    let mut _7: isize;
    let _8: ();
    let _9: *mut T;
    let _10: ();
    let mut _11: *mut libc::c_void;
    let mut _12: *mut T;
    let mut _17: usize; // iter.0
    let _4: usize; // x
    let _5: *mut T; // elem_ptr
    let mut _13: bool;
    let _14: usize;
    let mut _15: usize;
    let mut _16: usize;

    bb0: {
        _2 = copy ((*_1).1: usize);
        StorageLive(_17);
        _17 = const 0_usize;
        goto -> bb1;
    }

    bb1: {
        StorageLive(_3);
        StorageLive(_14);
        StorageLive(_13);
        StorageLive(_16);
        _16 = copy _17;
        _13 = Lt(move _16, copy _2);
        StorageDead(_16);
        switchInt(move _13) -> [0: bb6, otherwise: bb4];
    }

    bb2: {
        StorageLive(_9);
        _9 = std::intrinsics::black_box::<*mut T>(move _5) -> [return: bb7, unwind unreachable];
    }

    bb3: {
        StorageDead(_11);
        return;
    }

    bb4: {
        _14 = copy _17;
        StorageLive(_15);
        _15 = <usize as Step>::forward_unchecked(copy _14, const 1_usize) -> [return: bb5, unwind continue];
    }

    bb5: {
        _17 = move _15;
        StorageDead(_15);
        _3 = Option::<usize>::Some(copy _14);
        StorageDead(_13);
        StorageDead(_14);
        _4 = copy ((_3 as Some).0: usize);
        StorageLive(_6);
        _6 = copy ((*_1).2: *mut T);
        StorageLive(_7);
        _7 = copy _4 as isize (IntToInt);
        _5 = Offset(copy _6, copy _7);
        StorageDead(_7);
        StorageDead(_6);
        _8 = std::ptr::drop_in_place::<T>(copy _5) -> [return: bb2, unwind continue];
    }

    bb6: {
        StorageDead(_13);
        StorageDead(_14);
        StorageDead(_3);
        StorageDead(_17);
        StorageLive(_11);
        _12 = copy ((*_1).2: *mut T);
        _11 = copy _12 as *mut libc::c_void (PtrToPtr);
        _10 = free(move _11) -> [return: bb3, unwind unreachable];
    }

    bb7: {
        StorageDead(_9);
        StorageDead(_3);
        goto -> bb1;
    }
}
```

### MIR Control-flow Graph
![Pattern Code](./figures/CVE-2020-35892-3/pattern-CFG.svg)
![Target Code](./figures/CVE-2020-35892-3/prog-CFG.svg)

### MIR Data-Dependency Graph
![Pattern Code](./figures/CVE-2020-35892-3/pattern-DDG.svg)
![Target Code](./figures/CVE-2020-35892-3/prog-DDG.svg)

![Subgraph Isomorphism](./figures/CVE-2020-35892-3/sub-iso.svg)