# CVE-2020-35906

## Metadata

- RustSec: https://rustsec.org/advisories/RUSTSEC-2020-0060.html
- Mitre: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-35906
- Bug Report GitHub Issue/Release: https://github.com/rust-lang/futures-rs/pull/2206
- Bug Fix GitHub Commit/PR: https://github.com/rust-lang/futures-rs/pull/2206

## Source

```rust
pub fn waker<W>(wake: Arc<W>) -> core::task::Waker
where
    // bug fix:
    // W: ArcWake + 'static
    W: ArcWake,
{
    let ptr = Arc::into_raw(wake) as *const ();

    unsafe {
        Waker::from_raw(RawWaker::new(ptr, waker_vtable::<W>()))
    }
}
```

```rust
pub trait ArcWake: Send + Sync {
    fn wake(self: Arc<Self>) {
        Self::wake_by_ref(&self)
    }

    fn wake_by_ref(arc_self: &Arc<Self>);
}
```

## Description / Analysis

The futures::task::waker function currently allows you to transmute an Arc<T> into a Waker, even if T is not 'static. This can cause an use-after-free.

Because when you wish to convert an `Arc<W>` object into a `core::task::Waker` object and ensure it can wake up tasks as expected across different threads, you need to ensure that `W` has a `'static` lifetime constraint. This is because the `Waker` might be invoked from different threads, and it needs to ensure that the referenced object remains valid throughout the lifetimes of all associated threads.

```rust
use std::sync::Arc;
use futures::task::{waker, ArcWake};

struct MyRef<'a> {
    a: &'a str,
}

impl<'a> ArcWake for MyRef<'a> {
    fn wake_by_ref(arc_self: &Arc<Self>) {
        println!("{}", arc_self.a);
    }
}

fn main() {
    let string = "Hello World!".to_string();
    let waker = waker(Arc::new(MyRef { a: &string }));
    drop(string);
    waker.wake(); // This causes an use-after-free of the string.
}
```

## Fixes

- 'static

## Pattern Description

A transmute from `Arc<T>` to `Waker` should require that `T` is `'static`.

````rpl
pattern CVE-2020-35906

mvar {
    W: ident
    body: span
    raw: span
}

util {
    pat_erase_non_static = 
        pub fn _<$W>(_) -> _
        where
            $W: ?'static
        {
            let arc: Arc<$W> = _;
            let ptr: *const $W = #span!($raw, Arc::into_raw(arc));
            return #from!(ptr);
        }
}

patt {
    p_erase_non_static: err = pat_erase_non_static => EraseNonStatic {
        $raw,
        ty: $W,
    }
}

use {
    alloc::sync::Arc
    core::task::Waker
}

diag {
    #[derive(Diagnostic)]
    #[diag(transmute_non_static)]
    #[help]
    pub struct EraseNonStatic {
        #[primary_span]
        pub raw: Span,
        pub ty: Ident,
    }
}

msg {
    erase_non_static = eraseing non-`'static` `Arc<{$ty}>` can make dangling pointers
        .help = try adding constraint `{$ty}: 'static`
}
````