# CVE-2021-29941-2

## Metadata

- RustSec: https://rustsec.org/advisories/RUSTSEC-2021-0050.html
- Mitre:
  - https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-29941
  - https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-29942
- Bug Report GitHub Issue/Release: issues/1
- Bug Fix GitHub Commit/PR:

## Source

```rust
pub fn swap_index(bla: impl ExactSizeIterator<Item = u32>) -> Vec<u32> {
    let len = bla.len();
    let mut vec = Vec::with_capacity(len);
    let arr: &mut [u32] = unsafe { std::slice::from_raw_parts_mut(vec.as_mut_ptr(), bla.len()) };
    for (i, a) in bla.enumerate() {
        arr[a as usize] = i as u32;
    }

    unsafe {
        vec.set_len(len);
    }
    vec
}

```

## Description / Analysis

`ExactSizeIterator`'s `len()`'s safety requirements are same as `size_hint()`:

`size_hint()` is primarily intended to be used for optimizations such as reserving space for the elements of the iterator, but must not be trusted to e.g., omit bounds checks in unsafe code. An incorrect implementation of `size_hint()` should not lead to memory safety violations.

`swap_index`:

- can return uninitialized values if an iterator returns a `len()` that is too large.
- has an out-of-bounds write if an iterator returns a `len()` that is too small.

## Fixes

Interestingly, the `README.md` of the crate mentions that it will reorder a slice based on a slice of indices **without** an auxiliary array.

However, the newest version of the crate needs an auxiliary array to work correctly.

## Pattern Description

````rpl
pattern CVE-2021-29941

mvar {
    T: ty
    I: ty
    slice: span
    set_len: span
    len: span
}

util {
    p_uninit_fn = ?pub ?unsafe fn _(_) -> _ {
        let mut vec: Vec<$T> = Vec::with_capacity(_);
        let cap: usize = vec.capacity();
        let ptr: *mut $T = vec.as_mut_ptr();
        let _: &mut [$T] = unsafe { 
            #span!(slice, from_raw_parts_mut(ptr, cap));
        }
    }
    
    p_untrusted_len = pub fn _(_) -> _ where I: ExactSizeIterator {
        let iter: $I = _;
        let cap: usize = #span!($len, iter.len());
        let vec: usize = Vec::with_capacity(cap);
        unsafe {
            #span!($set_len, vec.set_len(cap));
        }
    }
}

patt {
    p: err = 
        | p_uninit_fn => VecUninitMem {
            $slice,
        }
        | p_untrusted_len = UntrustedLen {
            $len,
            $set_len,
        }
}

use {
    alloc::vec::Vec
    core::slice::from_raw_parts_mut
    core::iter::ExactSizeIterator
}

diag {
    #[derive(Diagnostic)]
    #[diag(vec_uninit_mem)]
    #[help]
    pub struct VecUninitMem {
        #[primary_span]
        pub slice: Span,
    }

    #[derive(Diagnostic)]
    #[diag(untrusted_len)]
    #[help]
    pub struct UntrustedLen {
        #[primary_span]
        pub iter: Span,
        #[label]
        pub set_len: Span,
    }
}

msg {
    vec_uninit_mem = construct a slice from uninitialized memory
        .help = consider using `Vec::spare_capacity_mut` instead

    untrusted_len = length from `ExactSizeIterator` cannot be trusted
        .label = `Vec::set_len` called here
        .help = try using the number of elements exactly yielded by the iterator
}
````
