# CVE-2023-28448

## Metadata

- RustSec: https://rustsec.org/advisories/RUSTSEC-2023-0030.html
- Mitre: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-28448
- Bug Report GitHub Issue/Release: [pull/53](https://github.com/firecracker-microvm/versionize/pull/53)
- Bug Fix GitHub Commit/PR: [pull/53](https://github.com/firecracker-microvm/versionize/pull/53)

## Source

```rust
#[inline]
fn deserialize<R: std::io::Read>(
    reader: &mut R,
    version_map: &VersionMap,
    app_version: u16,
) -> VersionizeResult<Self> {
    let header = T::deserialize(reader, version_map, app_version)
        .map_err(|ref err| VersionizeError::Deserialize(format!("{:?}", err)))?;
    let entries: Vec<<T as FamStruct>::Entry> =
        Vec::deserialize(reader, version_map, app_version)
            .map_err(|ref err| VersionizeError::Deserialize(format!("{:?}", err)))?;

    // Construct the object from the array items.
    // Header(T) fields will be initialized by Default trait impl.
    let mut object = FamStructWrapper::from_entries(&entries)
        .map_err(|ref err| VersionizeError::Deserialize(format!("{:?}", err)))?;
    // Update Default T with the deserialized header.
    *object.as_mut_fam_struct() = header;
    Ok(object)
}
```

## Description / Analysis

### Introduction to FAM

A **Flexible Array Member (FAM)** is a feature in C(C99) that allows the last member of a `struct` to be an array without a specified size. This array can then be dynamically allocated with a size determined at runtime.

In C, a struct with a flexible array member might look like this:

```c
struct S {
    int count;
    char data[];
};
```

In this example:

- `count` stores the number of elements in the `data` array.
- `data` is declared as an array with no specified size, meaning its size is flexible and can be determined when the struct is allocated.

To use a struct with a flexible array member, you would typically allocate memory dynamically using `malloc` or `calloc`:

```c
struct Example *example = malloc(sizeof(struct Example) + sizeof(char) * num_elements);
example->count = num_elements;
```

### Rust Implementation (in another crate)

```rust
pub unsafe trait FamStruct {
    type Entry: PartialEq + Copy;

    fn len(&self) -> usize;

    unsafe fn set_len(&mut self, len: usize);

    fn max_len() -> usize;

    fn as_slice(&self) -> &[Self::Entry];

    fn as_mut_slice(&mut self) -> &mut [Self::Entry];
}


#[derive(Debug)]
pub struct FamStructWrapper<T: Default + FamStruct> {
    mem_allocator: Vec<T>, // just a contigious memory block
}

impl<T: Default + FamStruct> FamStructWrapper<T> {
    // Some complex logic to manage the memory block
}
```

Here is an example of how `FamStructWrapper` is used:

```rust
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);

#[repr(C)]
#[derive(Default)]
struct MockFamStruct {
    pub len: u32,
    pub padding: u32,
    pub entries: __IncompleteArrayField<u32>,
}

unsafe impl FamStruct for MockFamStruct { ... }

type MockFamStructWrapper = FamStructWrapper<MockFamStruct>;
```

A serialized `FamStructWrapper` looks [as follows](https://github.com/firecracker-microvm/versionize/pull/53/commits/fffee7077153224edeabc0f5eaa347a646b6c1ee):

| Index                                                    | Content                                 |
| -------------------------------------------------------- | --------------------------------------- |
| `mem_allocator[0]`                                       | Header (containing `len` of the FAM)    |
| The first `size_of(usize)` bytes of `mem_allocator[1..]` | `len` of the FAM, equal to `header.len` |
| The rest of `mem_allocator[1..]`                         | Entries of the FAM                      |

So there are implicit safety invariants that:

- The length of the FAM specified in the header should match the actual size of the FAM.
- Two "len" fields should be equal.

## Fixes

Add check:

```rust
if header.len() != entries.len() {
    let msg = format!(
        "Mismatch between length of FAM specified in FamStruct header ({}) \
        and actual size of FAM ({})",
        header.len(),
        entries.len()
    );
    return Err(VersionizeError::Deserialize(msg));
}
```

## Pattern Description

TODO
