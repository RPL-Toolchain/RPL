# CVE-2023-41051

## Metadata

- RustSec: \_
- Mitre: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-41051
- Bug Report GitHub Issue/Release: \_
- Bug Fix GitHub Commit/PR: TODO

## Source

```rust
pub trait VolatileMemory {
    type B: Bitmap;

    fn get_slice(&self, offset: usize, count: usize) -> Result<VolatileSlice<BS<Self::B>>>;
    // no default implementation

    fn get_ref<T: ByteValued>(&self, offset: usize) -> Result<VolatileRef<T, BS<Self::B>>> {
        let slice = self.get_slice(offset, size_of::<T>())?;

        unsafe {
            Ok(VolatileRef::with_bitmap(
                slice.addr,
                slice.bitmap,
                slice.mmap,
            ))
        }
    }
}
```

## Description / Analysis

VolatileMemory::{get_atomic_ref, aligned_as_ref, aligned_as_mut, get_ref, get_array_ref} trait functions, which allows **out-of-bounds memory access** if the `VolatileMemory::get_slice` function returns a `VolatileSlice` whose length is less than the functionâ€™s count argument.

## Fixes

Inserting a check that verifies that the `VolatileSlice` returned by get_slice is of the correct length.

```rust
assert_eq!(
    slice.len(),
    size_of::<T>(),
    "VolatileMemory::get_slice(offset, count) returned slice of length != count."
);
```

## Pattern Description

TODO