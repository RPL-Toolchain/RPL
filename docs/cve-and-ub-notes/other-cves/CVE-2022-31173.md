# CVE-2022-31173

## Metadata

- RustSec: \_
- Mitre: https://www.cve.org/CVERecord?id=CVE-2022-31173
- Bug Report GitHub Issue/Release: \_
- Bug Fix GitHub Commit/PR: https://github.com/graphql-rust/juniper/commit/8d28cdba6eb10f53490ba41d1b5cb40506c2de22

## Source

```rust
// https://github.com/graphql-rust/juniper/blob/c6507139978253530a72f0612e3d56e48c8cb918/juniper/src/validation/rules/no_fragment_cycles.rs
struct CycleDetector<'a> {
    visited: HashSet<&'a str>,
    spreads: &'a HashMap<&'a str, Vec<Spanning<&'a str>>>,
    path_indices: HashMap<&'a str, usize>,
    errors: Vec<RuleError>,
}

impl<'a> CycleDetector<'a> {
    fn detect_from(&mut self, from: &'a str, path: &mut Vec<&'a Spanning<&'a str>>) {
        self.visited.insert(from);

        if !self.spreads.contains_key(from) {
            return;
        }

        self.path_indices.insert(from, path.len());

        for node in &self.spreads[from] {
            let name = &node.item;
            let index = self.path_indices.get(name).cloned();

            if let Some(index) = index {
                let err_pos = if index < path.len() {
                    path[index]
                } else {
                    node
                };

                self.errors
                    .push(RuleError::new(&error_message(name), &[err_pos.start]));
            } else if !self.visited.contains(name) {
                path.push(node);
                self.detect_from(name, path);
                path.pop();
            }
        }

        self.path_indices.remove(from);
    }
}
```

## Description / Analysis

### Fragment in GraphQL

In GraphQL, a fragment is a reusable unit of a query that can be used to reduce duplication. It is a collection of fields that can be included in multiple queries. Fragments are defined using the `fragment` keyword and can be included in a query using the `...` syntax.

```js
fragment UserFragment on User {
  id
  name
  email
}

fragment UserFragmentWithFriends on User {
  ...UserFragment
  friends {
    ...UserFragment
  }
}
```

### Fragment Cycles

A fragment cycle occurs when a fragment includes itself directly or indirectly. For example, consider the following fragments:

```js
fragment A on User {
  ...B
}

fragment B on User {
  ...A
}
```

In this case, fragment `A` includes fragment `B`, and fragment `B` includes fragment `A`. This creates a cycle, which can lead to infinite recursion and cause the query to fail.

### Cycle Detection Logic

The `CycleDetector` struct in the code snippet is used to detect fragment cycles in a GraphQL query. It maintains

- a set of visited nodes
- a mapping of fragment to other fragments it depends on
- a mapping of path indices
- and a list of errors encountered during cycle detection.

Logic:

- First, mark the current fragment from as visited to avoid traversing it again later. If the current fragment does not have any dependencies, return early.

- Add the current fragment to path_indices to record its position in the traversal path

- Traversing dependent fragments:

  - Traverse all the fragments that the current fragment depends on
  - Check if the fragment already exists in path_indices (i.e., if it has already been encountered in the current path). If it is found, a cycle is detected, and an error is recorded.
  - If no cycle is found and the fragment has not been visited yet, add it to the path and recursively detect its dependencies. Once the detection is finished, remove the fragment from the path.

- After completing the detection of all the dependencies for the current fragment, remove the fragment from path_indices to allow subsequent fragments to be processed.

**The logic for detecting cycles is correct, but when a cycle is large([example](https://github.com/graphql-rust/juniper/security/advisories/GHSA-4rx6-g5vg-5f3j)), the recursive calls can result in a stack overflow.**

## Fixes

```rust
struct CycleDetector<'a> {
    visited: HashSet<&'a str>,
    spreads: &'a HashMap<&'a str, Vec<Spanning<&'a str>>>,
    errors: Vec<RuleError>,
}

impl<'a> CycleDetector<'a> {
    fn detect_from(&mut self, from: &'a str) {
        let mut to_visit = Vec::new();
        to_visit.push((from, Vec::new(), HashMap::new()));

        while let Some((from, path, path_indices)) = to_visit.pop() {
            to_visit.extend(self.detect_from_inner(from, path, path_indices));
        }
    }

    /// This function should be called only inside [`Self::detect_from()`], as
    /// it's a recursive function using heap instead of a stack. So, instead of
    /// the recursive call, we return a [`Vec`] that is visited inside
    /// [`Self::detect_from()`].
    fn detect_from_inner(
        &mut self,
        from: &'a str,
        path: Vec<&'a Spanning<&'a str>>,
        mut path_indices: HashMap<&'a str, usize>,
    ) -> Vec<CycleDetectorState<'a>> {
        self.visited.insert(from);

        if !self.spreads.contains_key(from) {
            return Vec::new();
        }

        path_indices.insert(from, path.len());

        let mut to_visit = Vec::new();
        for node in &self.spreads[from] {
            let name = node.item;
            let index = path_indices.get(name).cloned();

            if let Some(index) = index {
                let err_pos = if index < path.len() {
                    path[index]
                } else {
                    node
                };

                self.errors
                    .push(RuleError::new(&error_message(name), &[err_pos.start]));
            } else {
                let mut path = path.clone();
                path.push(node);
                to_visit.push((name, path, path_indices.clone()));
            }
        }

        to_visit
    }
}
```

The bug-fixing code replaces recursion with an iterative approach using a manually managed stack `to_visit` to avoid stack overflow. Instead of recursive calls, the state is stored in the heap and processed **iteratively** in the `detect_from` function. 

## Pattern Description

