# CVE-2019-15542

## Metadata

- RustSec: https://rustsec.org/advisories/RUSTSEC-2019-0001.html
- Mitre: https://www.cve.org/CVERecord?id=CVE-2019-15542
- Bug Report GitHub Issue/Release: \_
- Bug Fix GitHub Commit/PR: https://github.com/rust-ammonia/ammonia/pull/113/commits/0a0bf58daa726c0d6d4b7c11cf1cab8edcfa9cf3

## Source / Bug fix

```Rust
/// Clean a post-parsing DOM.
///
/// This is not a public API because RcDom isn't really stable.
/// We want to be able to take breaking changes to html5ever itself
/// without having to break Ammonia's API.
fn clean_dom(&self, mut dom: RcDom) -> Document {
    let mut stack = Vec::new();
    + let mut removed = Vec::new();
    let link_rel = self
        .link_rel
        .map(|link_rel| format_tendril!("{}", link_rel));
    if link_rel.is_some() {
        assert!(self.generic_attributes.get("rel").is_none());
        assert!(self
            .tag_attributes
            .get("a")
            .and_then(|a| a.get("rel"))
            .is_none());
    }
    assert!(self.allowed_classes.is_empty() || !self.generic_attributes.contains("class"));
    for (tag_name, _classes) in &self.allowed_classes {
        assert!(self
            .tag_attributes
            .get(tag_name)
            .and_then(|a| a.get("class"))
            .is_none());
    }
    for tag_name in &self.clean_content_tags {
        assert!(!self.tags.contains(tag_name));
        assert!(!self.tag_attributes.contains_key(tag_name));
    }
    let url_base = if let UrlRelative::RewriteWithBase(ref base) = self.url_relative {
        Some(base)
    } else {
        None
    };
    let body = {
        let children = dom.document.children.borrow();
        children[0].clone()
    };
    stack.extend(
        replace(&mut *body.children.borrow_mut(), Vec::new())
            .into_iter()
            .rev(),
    );
    + // This design approach is used to prevent pathological content from producing
    + // a stack overflow. The `stack` contains to-be-cleaned nodes, while `remove`,
    + // of course, contains nodes that need to be dropped (we can't just drop them,
    + // because they could have a very deep child tree).
    while let Some(mut node) = stack.pop() {
        let parent = node.parent
                .replace(None).expect("a node in the DOM will have a parent, except the root, which is not processed")
                .upgrade().expect("a node's parent will be pointed to by its parent (or the root pointer), and will not be dropped");
        if self.clean_node_content(&node) {
    +       removed.push(node);
            continue;
        }
        let pass = self.clean_child(&mut node);
        if pass {
            self.adjust_node_attributes(&mut node, &link_rel, url_base, self.id_prefix);
            dom.append(&parent.clone(), NodeOrText::AppendNode(node.clone()));
        } else {
            for sub in node.children.borrow_mut().iter_mut() {
                sub.parent.replace(Some(Rc::downgrade(&parent)));
            }
        }
        stack.extend(
            replace(&mut *node.children.borrow_mut(), Vec::new())
                .into_iter()
                .rev(),
        );
    +   if !pass {
    +      removed.push(node);
    +   }
    }
    + // Now, imperatively clean up all of the child nodes.
    + // Otherwise, we could wind up with a DoS, either caused by a memory leak,
    + // or caused by a stack overflow.
    + while let Some(node) = stack.pop() {
    +    removed.extend_from_slice(&replace(&mut *node.children.borrow_mut(), Vec::new())[..]);
    + }
    Document(dom)
}
```

## Description / Analysis

The `Drop` implementation of a `RcDom` node: https://github.com/servo/html5ever/blob/main/rcdom/lib.rs#L128

```Rust
impl Drop for Node {
    fn drop(&mut self) {
        let mut nodes = mem::take(&mut *self.children.borrow_mut());
        while let Some(node) = nodes.pop() {
            let children = mem::take(&mut *node.children.borrow_mut());
            nodes.extend(children.into_iter());
            if let NodeData::Element {
                ref template_contents,
                ..
            } = node.data
            {
                if let Some(template_contents) = template_contents.borrow_mut().take() {
                    nodes.push(template_contents);
                }
            }
        }
    }
}
```

Possible analysis:

- Add a `removed` vector to store the nodes that need to be removed.
- When a node needs to be removed, push it to the `removed` vector.
- `while let Some(node) = stack.pop() { removed.extend_from_slice(&replace(&mut *node.children.borrow_mut(), Vec::new())[..]); }` split all nodes in a tree, and then process them one by one, which avoids stack overflow.("We can't just drop them, because they could have a very deep child tree").

## Fixes

TODO

## Pattern Description

TODO

```

```
