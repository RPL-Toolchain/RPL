pattern CVE-2020-35898-9

patt {
    use std::cell::UnsafeCell;
    use std::rc::Rc;
    use std::rc::RcInner;
    use std::ptr::NonNull;

    p_rc_unsafe_cell[
        $T: type
    ] = {                       
        pub struct $Cell {
            $inner: Rc<UnsafeCell<$T>>,
        }

        impl $Cell {
            fn $get_mut(..) -> _ {
                let $self: &mut $Cell = _;
                let $inner_ref: &Rc<UnsafeCell<$T>> = &(*$self).$inner;
                let $inner_ptr: NonNull<RcInner<UnsafeCell<$T>>> = copy (*$inner_ref).ptr;
                let $const_ptr: *const RcInner<UnsafeCell<$T>> = copy $inner_ptr as *const RcInner<UnsafeCell<$T>> (Transmute);
                let $unsafe_cell: &UnsafeCell<$T> = &(*$const_ptr).value;
                let $unsafe_cell_ptr: *const UnsafeCell<$T> = &raw const (*$unsafe_cell);
                let $value_ptr: *mut $T = copy $unsafe_cell_ptr as *mut $T (PtrToPtr);
                'get_mut:
                let $value_mut_ref: &mut $T = &mut (*$value_ptr);
            }
        }
    }
}

// detection after monomorpization?

diag {
    p_rc_unsafe_cell = {
        primary(get_mut) = "Obtaining a mutable reference to the value wrapped by `Rc<UnsafeCell<$T>>` may be unsound",
        label(get_mut)   = "`UnsafeCell::get_mut` called here",
        note             = "there will be multiple mutable references to the value at the same time",
        help             = "use `std::cell::RefCell` instead",
        name             = "get_mut_in_rc_unsafecell",
        level            = "deny",
    }
}
