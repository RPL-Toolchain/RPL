pattern CVE-2020-35892-3

patt {
    use core::ops::range::Range<usize>;

    // how to express constraints on meta variables?
    // 1. use a where clause (how to define a where clause?)
    // 2. use a predicate (how to define a predicate?)
    p[
        $T: type,
        $SlabT: type
    ]
    = #[mir] fn _ (..) -> _ {
        let $self: &mut $SlabT;
        let $len: usize = copy (*$self).len;
        let $range: Range<usize> = Range { start: const 0_usize, end: move $len };
        let $iter: Range<usize> = move $range;
        loop {
            let $iter_mut: &mut Range<usize> = &mut $iter;
            let $start_ref: &usize = &(*$iter_mut).start;
            let $start: usize = copy *$start_ref;
            let $end_ref: &usize = &(*$iter_mut).end;
            let $end: usize = copy *$end_ref;
            let $cmp: bool = Lt(move $start, move $end);
            let $opt: Option<usize>;
            switchInt(move $cmp) {
                false => $opt = #[lang = "None"],
                _ => {
                    let $x1: usize = copy (*$iter_mut).start;
                    let $x2: usize = core::iter::range::Step::forward_unchecked(copy $x1, const 1_usize);
                    (*$iter_mut).start = move $x2;
                    $opt = #[lang = "Some"](copy $x1);
                }
            }
            let $discr: isize = discriminant($opt);
            switchInt(move $discr) {
                0_isize => break,
                1_isize => {
                    let $x: usize = copy ($opt as Some).0;
                    let $base: *mut $T = copy (*$self).mem;
                    let $offset: isize = copy $x as isize (IntToInt);
                    let $elem_ptr: *mut $T = Offset(copy $base, copy $offset);
                    _ = core::ptr::drop_in_place(copy $elem_ptr);
                }
            }
        }
    }
}