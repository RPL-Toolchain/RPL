# CVE-2024-27284

## Metadata

-   RustSec: \_
-   Mitre: https://www.cve.org/CVERecord?id=CVE-2024-27284
-   Bug Report GitHub Issue/Release: https://github.com/cassandra-rs/cassandra-rs/security/advisories/GHSA-x9xc-63hg-vcfq
-   Bug Fix GitHub Commit/PR: https://github.com/cassandra-rs/cassandra-rs/commit/ae054dc8044eac9c2c7ae2b1ab154b53ca7f8df7

## Description / Analysis

Code that attempts to **use an item returned by an iterator after the iterator has advanced to the next item** will be accessing freed memory, which caused by the underlying Cassandra driver which invalidates the current item when `next()` is called, leading to a **use-after-free** vulnerability.

### 'Giving' Traits

In a 'giving' trait, invoking its methods returns a value that is **independent** of `self`.

The `std::iter::Iterator` is a 'giving' trait.

```rust
trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;
    //      ^ the lifetime of the `&mut self` reference
    //        does not appear in the return type;
}
```

In `Iterator`, each time we invoke the `next` method, we get ownership of a `Self::Item` value (or None), which is not borrowed from the iterator `self`.

So we can write code like this:

```rust
fn print_two_values_v1<T: Iterator>(iter: &mut T)
where
    T::Item: std::fmt::Debug,
{
    let Some(first) = iter.next() else {
        return;
    };
    let Some(second) = iter.next() else {
        return;
    };
    // The item `first` is still live here, even though we called `next`.
    // So we can print it.
    print!("{:?}", first);
    print!("{:?}", second);
}
```

### 'Lending' Traits

In a 'lending' trait, invoking its methods returns a value that is **borrowed** from `self`.

The trait `LendingIterator` that is defined below is a 'lending' trait.

```rust
trait LendingIterator {
    type Item<'a>
    where
        Self: 'a;

    fn next<'a>(&'a mut self) -> Option<Self::Item<'a>>;
    //          ^                           ^^
    // Unlike `Iterator`, returns a value
    // potentially borrowed from `self`.
}
```

In `LendingIterator`, each time we invoke the `next` method, we may get a borrowed reference to a `Self::Item`.

> When you use a lending iterator, it is lending values to you; you have to “give them back” (stop using them) before you can invoke next again.

The following code will not compile without the line 9 `drop(first)`:

```rust
fn print_two_values_v2<T: LendingIterator>(iter: &mut T)
where
    for<'a> T::Item<'a>: std::fmt::Debug,
{
    let Some(first) = iter.next() else {
        return;
    };
    print!("{:?}", first);
    // drop(first);

    let Some(second) = iter.next() else {
        return;
    };
    print!("{:?}", second);
}
```

```text
error[E0499]: cannot borrow `*iter` as mutable more than once at a time
  --> src/main.rs:35:24
   |
29 |     let Some(first) = iter.next() else {
   |                       ---- first mutable borrow occurs here
...
35 |     let Some(second) = iter.next() else {
   |                        ^^^^ second mutable borrow occurs here
...
39 | }
   | - first borrow might be used here, when `first` is dropped and runs the destructor for type `<T as LendingIterator>::Item<'_>`
```

> Compared with
>
> ```rust
> fn main() {
>     let mut a = 5;
>
>     let mut_ref_a_1 = &mut a;
>     let reborrow_from_mut_ref_a_1 = &*mut_ref_a_1;
>     print!("{:?}", reborrow_from_mut_ref_a_1);
>
>     let mut_ref_a_2 = &mut a;
>     let reborrow_from_mut_ref_a_2 = &*mut_ref_a_2;
>     print!("{:?}", reborrow_from_mut_ref_a_2);
> }
> ```

### Description to the CVE

The underlying Cassandra driver (a C++ driver) invalidates the current item when `next()` is called. The Rust wrapper should behave like a 'lending' iterator instead of a 'giving' iterator. This leads to a **use-after-free** vulnerability.

## Source

```rust
pub struct AggregateMeta(*const _CassAggregateMeta);
impl AggregateMeta {
    fn build(inner: *const _CassAggregateMeta) -> Self {
        if inner.is_null() {
            panic!("Unexpected null pointer")
        };
        AggregateMeta(inner)
    }
}
#[derive(Debug)]
pub struct AggregateIterator(*mut _CassIterator);

impl Iterator for AggregateIterator {
    type Item = AggregateMeta;
    fn next(&mut self) -> Option<<Self as Iterator>::Item> {
        unsafe {
            match cass_iterator_next(self.0) {
                cass_false => None,
                cass_true => {
                    let field_value = cass_iterator_get_aggregate_meta(self.0);
                    Some(AggregateMeta::build(field_value))
                }
            }
        }
    }
}
```

## Detection of this vulnerability by RPL

RPL is partially capable of identifying this vulnerability through pattern matching. However, we issue a warning rather than an error due to the following reasons:

1. RPL-toolchain is currently unable to match full implementation of a trait and can only detect functions defined within the trait.
2. Additionally, the expected pattern should consist of the following sequence:
    1. Move the `$ptr` to next position via the `cass_iterator_next` function call.
    2. If step 1 is successful, get an item via the `cass_iterator_get_\*($ptr)` function call.
    3. The return value of the `next` method (within the `std::iter::Iterator` trait) should include the item obtained in the previous step. (RPL currently lack relevant data flow analysis capabilities.)

## Reference

-   https://blog.rust-lang.org/2022/11/03/Rust-1.65.0.html#generic-associated-types-gats
-   https://docs.rs/lender/latest/lender/
-   https://github.com/datastax/cpp-driver/blob/86f916fc42e0e1adb88d12a92af7d94132d737b6/src/iterator.cpp#L33
-   https://smallcultfollowing.com/babysteps/blog/2023/05/09/giving-lending-and-async-closures/

where cass_iterator_next is defined as:

```cpp
cass_bool_t cass_iterator_next(CassIterator* iterator) {
  return static_cast<cass_bool_t>(iterator->from()->next());
}

// maybe more
```
