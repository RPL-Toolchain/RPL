# CVE-2020-35888

## Metadata

-   RustSec: https://rustsec.org/advisories/RUSTSEC-2020-0034.html
-   Mitre: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-35888
-   Bug Report GitHub Issue/Release: https://github.com/sjep/array/issues/1
-   Bug Fix GitHub Commit/PR: https://github.com/sjep/array/commit/34380d886168061149af0ee47fe07a74b7ebf4e2#diff-b1a35a68f14e696205874893c07fd24fdb88882b47c23cc0e0c80a30c7d53759R119

## Keypoints

-   Drop of uninitialized memory.
-   The behavior of the assignment operator `=`.

## A simple example

```rust
use std::alloc::{alloc, Layout};

struct DropDetector(u32);

impl Drop for DropDetector {
    fn drop(&mut self) {
        println!("Dropping value: {} at {:?}", self.0, self as *const _);
    }
}

fn main() {
    let layout = Layout::new::<DropDetector>();
    println!("The DropDetector layout is {:?}", layout);

    let ptr: *mut DropDetector = unsafe { alloc(layout) as *mut DropDetector };
    println!("Allocated {} bytes at {:?}", layout.size(), ptr);

    unsafe {
        (*ptr) = DropDetector(12345);
            // ^ what happens here?
        std::ptr::drop_in_place(ptr);
    }
}
```

output:

```c
The DropDetector layout is Layout { size: 4, align: 4 (1 << 2) }
Allocated 4 bytes at 0x147e05d50
Dropping value: 0 at 0x147e05d50
Dropping value: 12345 at 0x147e05d50
```

## Description / Analysis

The behavior of the assignment expressions:

-   Evaluating assignment expressions begins by evaluating its operands. The assigned value operand is evaluated first, followed by the assignee expression.
-   **It then has the effect of first dropping the value at the assigned place**, unless the place is an uninitialized local variable or an uninitialized field of a local variable.
-   Next it either copies or moves the assigned value to the assigned place.

## Source

```rust
use std::alloc::{alloc, Layout};

pub struct Array<T> {
    size: usize,
    ptr: *mut T,
}

impl<T> Array<T>
where
    T: Clone,
{
    /// More generic initialization instantiating all elements as copies of some template
    pub fn new_from_template(size: usize, template: &T) -> Self {
        let objsize = std::mem::size_of::<T>();
        let layout = Layout::from_size_align(size * objsize, 8).unwrap();
        let ptr = unsafe { alloc(layout) as *mut T };
        println!("Allocated {} bytes at {:?}", layout.size(), ptr);
        for i in 0..size {
            unsafe {
                (*(ptr.wrapping_offset(i as isize))) = template.clone();
            }
        }
        Self { size, ptr }
    }
}

#[derive(Clone, Debug)]
struct DropDetector(u32);

impl Drop for DropDetector {
    fn drop(&mut self) {
        println!("Dropping value: {} at {:?}", self.0, self as *const _);
    }
}
fn main() {
    let array = Array::new_from_template(2, &DropDetector(12345));
    for i in 0..array.size {
        // drop elements
        unsafe {
            let ptr = array.ptr.wrapping_offset(i as isize);
            std::ptr::drop_in_place(ptr);
        }
    }
}
```

## Fixes

The fix is to use `std::ptr::write` instead of the assignment operator `=`:

```rust
ptr.wrapping_offset(i as isize).write(template.clone());
```

The `write` method overwrites a memory location with the given value without reading or dropping the old value.
