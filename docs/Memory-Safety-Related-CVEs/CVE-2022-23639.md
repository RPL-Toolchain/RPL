# CVE-2022-23639

## Metadata

-   RustSec: \_
-   Mitre: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-23639
-   Bug Report GitHub Issue/Release: https://github.com/crossbeam-rs/crossbeam/pull/781
-   Bug Fix GitHub Commit/PR: https://github.com/crossbeam-rs/crossbeam/pull/781

## Source

```rust
use std::cell::UnsafeCell;
use std::sync::atomic::AtomicU64;
use std::sync::atomic::Ordering;

#[repr(transparent)]
pub struct AtomicCell<T: ?Sized> {
    /// The inner value.
    ///
    /// If this value can be transmuted into a primitive atomic type, it will be treated as such.
    /// Otherwise, all potentially concurrent operations on this data will be protected by a global
    /// lock.
    value: UnsafeCell<T>,
}

impl<T> AtomicCell<T> {
    pub const fn new(val: T) -> AtomicCell<T> {
        AtomicCell {
            value: UnsafeCell::new(val),
        }
    }
}

// impl_arithmetic!(u64, AtomicU64, "let a = AtomicCell::new(7u64);");
impl AtomicCell<u64> {
    // Provides an atomic operation to incrementally update the value in the container
    pub fn fetch_add(&self, val: u64) -> u64 {
        let a = unsafe { &*(self.value.get() as *const AtomicU64) };
        a.fetch_add(val, Ordering::AcqRel)
    }
}

```

## Description / Analysis

crossbeam-utils incorrectly assumed that the alignment of `{i,u}64` was always the same as `Atomic{I,U}64`. However, the alignment of `{i,u}64` on a 32-bit target can be smaller than `Atomic{I,U}64`.

Take u64/AtomicU64 as an example:

On 64-bit targets:

| Type      | Size | Alignment |
| --------- | ---- | --------- |
| `u64`       | 8    | 8         |
| `AtomicU64` | 8    | 8         |

On many 32-bit platfroms:

| Type      | Size | Alignment |
| --------- | ---- | --------- |
| `u64`       | 8    | 4         |
| `AtomicU64` | 8    | 8         |

> This type(`AtomicI64`) has the same size and bit validity as the underlying integer type, `i64`. However, the alignment of this type is always equal to its size, even on targets where i64 has a lesser alignment.
> Alignment is the requirement that data types be stored in memory at addresses that are multiples of their size or a specific number, ensuring efficient CPU access.

## Fixes

```rust
pub fn fetch_add(&self, val: u64) -> u64 {
    if can_transmute::<u64, AtomicU64>() {
        let a = unsafe { &*(self.value.get() as *const AtomicU64) };
        a.fetch_add(val, Ordering::AcqRel)
    } else {
        #[cfg(crossbeam_loom)]
        {
            let _ = val;
            unimplemented!("loom does not support non-atomic atomic ops");
        }
        #[cfg(not(crossbeam_loom))]
        {
            let _guard = lock(self.value.get() as usize).write();
            let value = unsafe { &mut *(self.value.get()) };
            let old = *value;
            *value = value.wrapping_add(val);
            old
        }
    }
}
```

```rust
const fn can_transmute<A, B>() -> bool {
    // Sizes must be equal, but alignment of `A` must be greater or equal than that of `B`.
    (mem::size_of::<A>() == mem::size_of::<B>()) & (mem::align_of::<A>() >= mem::align_of::<B>())
}
```

## Reference

-   AtomicI64: https://doc.rust-lang.org/std/sync/atomic/struct.AtomicI64.html
-   Atomic Types: https://doc.rust-lang.org/std/sync/atomic/index.html
-   Atomic Ordering: https://doc.rust-lang.org/std/sync/atomic/enum.Ordering.html
