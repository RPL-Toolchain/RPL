# CVE-2022-23639

## Metadata

-   RustSec: \_
-   Mitre: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-23639
-   Bug Report GitHub Issue/Release: https://github.com/crossbeam-rs/crossbeam/pull/781
-   Bug Fix GitHub Commit/PR: https://github.com/crossbeam-rs/crossbeam/pull/781

## Source

````rust
use std::cell::UnsafeCell;
use std::sync::atomic::AtomicU64;
use std::sync::atomic::Ordering;

#[repr(transparent)]
pub struct AtomicCell<T: ?Sized> {
    /// The inner value.
    ///
    /// If this value can be transmuted into a primitive atomic type, it will be treated as such.
    /// Otherwise, all potentially concurrent operations on this data will be protected by a global
    /// lock.
    value: UnsafeCell<T>,
}

impl<T> AtomicCell<T> {                     
    /// Creates a new atomic cell initialized with `val`.
    ///
    /// # Examples
    ///
    /// ```
    /// use crossbeam_utils::atomic::AtomicCell;
    ///
    /// let a = AtomicCell::new(7);
    /// ```
    pub const fn new(val: T) -> AtomicCell<T> {
        AtomicCell {
            value: UnsafeCell::new(val),
        }
    }
}

macro_rules! impl_arithmetic {
    ($t:ty, $atomic:ty, $example:tt) => {
        impl AtomicCell<$t> {
            /// Increments the current value by `val` and returns the previous value.
            ///
            /// The addition wraps on overflow.
            ///
            /// # Examples
            ///
            /// ```
            /// use crossbeam_utils::atomic::AtomicCell;
            ///
            #[doc = $example]
            ///
            /// assert_eq!(a.fetch_add(3), 7);
            /// assert_eq!(a.load(), 10);
            /// ```
            #[inline]
            pub fn fetch_add(&self, val: $t) -> $t {
                let a = unsafe { &*(self.value.get() as *const $atomic) };
                a.fetch_add(val, Ordering::AcqRel)
            }
        }
    };
}

#[rpl::dump_mir(dump_cfg, dump_ddg)]
impl_arithmetic!(u64, AtomicU64, "let a = AtomicCell::new(7u64);");

````

## Description / Analysis

crossbeam-utils incorrectly assumed that the alignment of `{i,u}64` was always the same as `Atomic{I,U}64`. However, the alignment of `{i,u}64` on a 32-bit target can be smaller than `Atomic{I,U}64`.

This type(`AtomicI64`) has the same size and bit validity as the underlying integer type, `i64`. However, the alignment of this type is always equal to its size, even on targets where i64 has a lesser alignment.

Alignment is the requirement that data types be stored in memory at addresses that are multiples of their size or a specific number, ensuring efficient CPU access.

## Fixes

```rust
pub fn fetch_add(&self, val: $t) -> $t {
    if can_transmute::<$t, $atomic>() {
        let a = unsafe { &*(self.value.get() as *const $atomic) };
        a.fetch_add(val, Ordering::AcqRel)
    } else {
        #[cfg(crossbeam_loom)]
        {
            let _ = val;
            unimplemented!("loom does not support non-atomic atomic ops");
        }
        #[cfg(not(crossbeam_loom))]
        {
            let _guard = lock(self.value.get() as usize).write();
            let value = unsafe { &mut *(self.value.get()) };
            let old = *value;
            *value = value.wrapping_add(val);
            old
        }
    }
}
```

```rust
const fn can_transmute<A, B>() -> bool {
    // Sizes must be equal, but alignment of `A` must be greater or equal than that of `B`.
    (mem::size_of::<A>() == mem::size_of::<B>()) & (mem::align_of::<A>() >= mem::align_of::<B>())
}
```

## Reference

AtomicI64: https://doc.rust-lang.org/std/sync/atomic/struct.AtomicI64.html
Atomic Types: https://doc.rust-lang.org/std/sync/atomic/index.html
